/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

bool __thiscall std::basic_ostream<char,std::char_traits<char>>::sentry::operator bool(std::basic_ostream<char,std::char_traits<char> >::sentry *this); // idb
void __thiscall std::bad_alloc::~bad_alloc(std::bad_alloc *this); // idb
errno_t __cdecl j___wmakepath_s(wchar_t *PathResult, size_t SIZE, const wchar_t *Drive, const wchar_t *Dir, const wchar_t *Filename, const wchar_t *Ext);
_crt_argv_mode __cdecl j___get_startup_argv_mode(); // idb
bool __cdecl j____acrt_uninitialize(bool __formal); // idb
bool __cdecl j____scrt_stub_for_acrt_initialize(); // idb
void __cdecl operator delete(void *block); // idb
int __cdecl j___configthreadlocale(_DWORD); // weak
void __cdecl j___crt_debugger_hook(int reserved); // idb
int j___get_initial_narrow_environment(void); // weak
void __cdecl operator delete(void *block, unsigned int __formal); // idb
int j___initialize_default_precision(void); // weak
errno_t __cdecl j__wcscpy_s(wchar_t *Dst, rsize_t SizeInWords, const wchar_t *Src);
int __cdecl j___free_dbg(_DWORD, _DWORD); // weak
int (*__cdecl j___CRT_RTC_INITW(void *__formal, void **__formal, int __formal, int __formal, int __formal))(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...); // idb
void __cdecl j____scrt_fastfail(unsigned int code); // idb
void __thiscall std::bad_alloc::bad_alloc(std::bad_alloc *this); // idb
int __cdecl j____scrt_is_ucrt_dll_in_use();
void __thiscall std::bad_array_new_length::~bad_array_new_length(std::bad_array_new_length *this); // idb
void __thiscall std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(std::basic_ostream<char,std::char_traits<char> >::_Sentry_base *this, std::basic_ostream<char,std::char_traits<char> > *_Ostr); // idb
_TEB *__cdecl j__NtCurrentTeb(); // idb
int __cdecl j___get_startup_commit_mode(); // idb
int j___except_handler4_common(_DWORD, const char *, ...); // weak
bool __cdecl j____acrt_thread_detach(); // idb
void __cdecl _RTC_AllocaFailure(void *retaddr, _RTC_ALLOCA_NODE *pn, int num); // idb
unsigned int __cdecl FindOffset(void *hProcess, char *pattern, const char *mask, unsigned int baseStart, unsigned int baseEnd); // idb
void __thiscall std::exception::~exception(std::exception *this); // idb
int __cdecl j____scrt_initialize_winrt(); // idb
void __thiscall std::bad_alloc::bad_alloc(std::bad_alloc *this, const char *const _Message); // idb
int __cdecl j___get_startup_thread_locale_mode(); // idb
void __cdecl j___cexit();
_crt_app_type __cdecl __scrt_main_policy::get_app_type(); // idb
int __cdecl j__atexit(void (__cdecl *function)()); // idb
int (*__cdecl _RTC_GetErrorFuncW(const void *__formal))(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...); // idb
void *__cdecl j__memset(void *Dst, int Val, size_t Size);
void __cdecl __scrt_throw_std_bad_alloc(); // idb
bool __cdecl std::char_traits<char>::eq_int_type(const int *_Left, const int *_Right); // idb
size_t __cdecl j__strlen(const char *Str);
void *__cdecl j__malloc(size_t Size);
int __cdecl j__strcmp(const char *Str1, const char *Str2);
unsigned int __cdecl std::char_traits<char>::length(const char *_First); // idb
void __cdecl j___RTC_UninitUse(const char *varname); // idb
int j___RTC_Initialize(void); // weak
void __cdecl _RTC_StackFailure(void *retaddr, const char *varname); // idb
void __cdecl j____report_securityfailure(unsigned int failure_code); // idb
int __cdecl j____std_type_info_destroy_list(_DWORD); // weak
errno_t __cdecl j___set_fmode(int Mode);
int __cdecl std::char_traits<char>::eof(); // idb
BOOL __stdcall Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
bool __cdecl j____vcrt_thread_attach(); // idb
int __cdecl FillProcessList(unsigned int *processList); // idb
int __cdecl j____std_exception_copy(_DWORD, _DWORD); // weak
bool __cdecl j____acrt_uninitialize_critical_0(bool __formal); // idb
int __cdecl j___callnewh(_DWORD); // weak
int j____p__commode(void); // weak
int j____scrt_is_user_matherr_present(void); // weak
int j____isa_available_init(void); // weak
bool __cdecl j____scrt_is_managed_app(); // idb
void (__cdecl **__cdecl __crt_fast_decode_pointer<void (__cdecl **)(void)>(void (__cdecl **const p)()))(); // idb
int __stdcall __scrt_unhandled_exception_filter(_EXCEPTION_POINTERS *const pointers); // idb
int __cdecl j___vsprintf_s_l(char *const _Buffer, const unsigned int _BufferCount, const char *const _Format, __crt_locale_pointers *const _Locale, char *_ArgList); // idb
bool __cdecl j____acrt_thread_detach_0(); // idb
int __cdecl j____stdio_common_vsprintf_s(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int j____scrt_set_unhandled_exception_filter(void); // weak
bool __cdecl j____scrt_uninitialize_crt(bool is_terminating, bool from_exit); // idb
bool __cdecl j____acrt_uninitialize_critical_1(bool __formal); // idb
int __cdecl j___crt_at_quick_exit(_DWORD); // weak
void __cdecl j___RTC_Terminate(); // idb
void __thiscall std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this); // idb
int j___initialize_invalid_parameter_handler(void); // weak
int __cdecl j___set_new_mode(_DWORD); // weak
void __thiscall type_info::~type_info(type_info *this); // idb
int __cdecl j___matherr(_exception *__formal); // idb
int __cdecl j___vfprintf_l(_iobuf *const _Stream, const char *const _Format, __crt_locale_pointers *const _Locale, char *_ArgList); // idb
unsigned int __cdecl __crt_rotate_pointer_value(const unsigned int value, const int shift); // idb
int __cdecl j___get_startup_new_mode(); // idb
int __cdecl j___set_app_type(_DWORD); // weak
void __cdecl j____raise_securityfailure(_EXCEPTION_POINTERS *const exception_pointers); // idb
int __vcrt_va_start_verify_argument_type<char const * const>(void); // weak
int j___initialize_denormal_control(void); // weak
int __cdecl j___initialize_onexit_table(_DWORD); // weak
int (*__cdecl j___RTC_SetErrorFuncW(int (*func)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...)))(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...); // idb
void __thiscall std::exception::exception(std::exception *this, const char *const _Message, int __formal); // idb
int j___initialize_narrow_environment(void); // weak
unsigned __int64 *__cdecl j____local_stdio_scanf_options(); // idb
void __thiscall std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(std::basic_ostream<char,std::char_traits<char> >::sentry *this); // idb
BOOL __stdcall Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
int j____security_init_cookie(void); // weak
bool __cdecl j____acrt_uninitialize_1(bool __formal); // idb
void __cdecl __scrt_initialize_type_info(); // idb
BOOL __stdcall Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
int j__terminate(void); // weak
void __thiscall std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(std::basic_ostream<char,std::char_traits<char> >::_Sentry_base *this); // idb
bool __cdecl j____scrt_stub_for_acrt_initialize_1(); // idb
bool __cdecl j____scrt_initialize_onexit_tables(__scrt_module_type module_type); // idb
errno_t __cdecl j___controlfp_s(unsigned int *CurrentState, unsigned int NewValue, unsigned int Mask);
bool __cdecl CheckPattern(const char *mask, char *buffer, char *pattern, unsigned int length); // idb
int j____scrt_initialize_default_local_stdio_options(void); // weak
int __cdecl __scrt_narrow_argv_policy::configure_argv(); // idb
void *__cdecl operator new(unsigned int size); // idb
int (__cdecl *__cdecl j___onexit(int (__cdecl *function)()))(); // idb
int __cdecl j___seh_filter_dll(_DWORD, _DWORD); // weak
int j____p___argc(void); // weak
int __cdecl j____std_exception_destroy(_DWORD); // weak
int __cdecl j____p___argv(_DWORD); // weak
void __fastcall __security_check_cookie(unsigned int cookie); // idb
int __cdecl j___register_onexit_function(_DWORD, _DWORD); // weak
int __cdecl GetNumberOfThreads(int processId); // idb
bool __cdecl j____scrt_initialize_crt(__scrt_module_type module_type); // idb
void __fastcall _guard_check_icall_nop(unsigned int Target); // idb
HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
bool __cdecl j____vcrt_thread_attach_1(); // idb
int __cdecl j__main(int argc, const char **argv); // idb
errno_t __cdecl j___wsplitpath_s(const wchar_t *FullPath, wchar_t *Drive, size_t DriveSize, wchar_t *Dir, size_t DirSize, wchar_t *Filename, size_t FilenameSize, wchar_t *Ext, size_t ExtSize);
void __thiscall std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char> >::sentry *this, std::basic_ostream<char,std::char_traits<char> > *_Ostr); // idb
int __cdecl j___is_c_termination_complete(); // idb
void __cdecl __scrt_throw_std_bad_array_new_length(); // idb
void __fastcall _guard_check_icall(unsigned int Target); // idb
void __cdecl __noreturn j__exit_0(int Code);
int __cdecl j___configure_narrow_argv(_DWORD); // weak
BOOL __stdcall Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
int __cdecl j____setusermatherr(_DWORD); // weak
int __cdecl j____vcrt_GetModuleFileNameW(_DWORD, _DWORD, _DWORD); // weak
void (__cdecl **__cdecl __crt_fast_encode_pointer<void (__cdecl **)(void)>(void (__cdecl **const p)()))(); // idb
BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);
int __cdecl _CxxThrowException(_DWORD, _DWORD); // weak
int (*__cdecl _RTC_GetErrorFunc(const void *__formal))(int, const char *, int, const char *, const char *, ...); // idb
std::basic_ostream<char,std::char_traits<char> > *__cdecl std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char> > *_Ostr, const char *_Val); // idb
int j__sprintf_s(char *const _Buffer, const unsigned int _BufferCount, const char *const _Format, ...); // idb
void __thiscall std::bad_alloc::bad_alloc(std::bad_alloc *this, std::bad_alloc *__that); // idb
void __cdecl j____scrt_release_startup_lock(bool is_nested); // idb
BOOL __stdcall Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
bool __cdecl j____scrt_acquire_startup_lock(); // idb
int __cdecl j___crt_atexit(_DWORD); // weak
int __cdecl _RTC_GetSrcLine(char *address, wchar_t *source, unsigned int sourcelen, int *pline, wchar_t *moduleName, unsigned int modulelen); // idb
void __thiscall std::exception::exception(std::exception *this, std::exception *_Other); // idb
int j__printf(const char *const _Format, ...); // idb
unsigned __int64 *__cdecl j____local_stdio_printf_options(); // idb
int __cdecl j___execute_onexit_table(_DWORD); // weak
int __cdecl j___get_startup_file_mode(); // idb
int __cdecl j____vcrt_LoadLibraryExW(_DWORD, _DWORD, _DWORD); // weak
bool __cdecl j____scrt_is_nonwritable_in_current_image(const void *target); // idb
bool __cdecl j___should_initialize_environment(); // idb
int __cdecl j____vcrt_GetModuleHandleW(_DWORD); // weak
unsigned __int64 __cdecl std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char> > *_Ostr, const char *_Val);
signed int __vcrt_va_start_verify_argument_type<char const * const>();
void __thiscall std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(std::basic_ostream<char,std::char_traits<char> >::_Sentry_base *this, std::basic_ostream<char,std::char_traits<char> > *_Ostr); // idb
void __thiscall std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char> >::sentry *this, std::basic_ostream<char,std::char_traits<char> > *_Ostr); // idb
void __thiscall std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(std::basic_ostream<char,std::char_traits<char> >::_Sentry_base *this); // idb
void __thiscall std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(std::basic_ostream<char,std::char_traits<char> >::sentry *this); // idb
bool __thiscall std::basic_ostream<char,std::char_traits<char>>::sentry::operator bool(std::basic_ostream<char,std::char_traits<char> >::sentry *this); // idb
char __cdecl CheckPattern(const char *mask, char *buffer, char *pattern, unsigned int length);
int __cdecl FillProcessList(unsigned int *processList); // idb
unsigned int __cdecl FindOffset(void *hProcess, char *pattern, const char *mask, unsigned int baseStart, unsigned int baseEnd); // idb
unsigned __int64 __cdecl GetNumberOfThreads(int processId);
void __cdecl __empty_global_delete();
void __cdecl __empty_global_delete();
int __cdecl std::char_traits<char>::eof(); // idb
bool __cdecl std::char_traits<char>::eq_int_type(const int *_Left, const int *_Right); // idb
unsigned int __cdecl std::char_traits<char>::length(const char *_First); // idb
unsigned __int64 *__cdecl __local_stdio_printf_options(); // idb
int __cdecl _vfprintf_l(_iobuf *const _Stream, const char *const _Format, __crt_locale_pointers *const _Locale, char *_ArgList); // idb
void __cdecl main(int argc, const char **argv);
int printf(const char *const _Format, ...); // idb
void *__cdecl operator new(unsigned int size); // idb
void __cdecl operator delete(void *block);
void __fastcall _RTC_CheckStackVars2(void *frame, _RTC_framedesc *v, _RTC_ALLOCA_NODE *allocaList); // idb
void __fastcall _RTC_CheckStackVars(void *frame, _RTC_framedesc *v); // idb
int (*__cdecl _CRT_RTC_INIT())(int, const char *, int, const char *, const char *, ...);
int (*__cdecl _CRT_RTC_INITW())(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...);
void _RTC_InitBase();
int (*_RTC_Shutdown())(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...);
int __cdecl DebuggerProbe(unsigned int dwLevelRequired); // idb
int __cdecl DebuggerRuntime(unsigned int dwErrorNumber, int bRealBug, void *pvReturnAddr, const wchar_t *pwMessage); // idb
void __cdecl _RTC_AllocaFailure(void *retaddr, _RTC_ALLOCA_NODE *pn, int num); // idb
void __cdecl _RTC_Failure(void *retaddr, int errnum); // idb
void __cdecl _RTC_StackFailure(void *retaddr, const char *varname); // idb
void __cdecl getMemBlockDataString(char *printbuff, char *valbuff, char *data, unsigned int datasize); // idb
unsigned int __cdecl strlen_priv(const char *str); // idb
void __cdecl failwithmessage(void *retaddr, int crttype, int errnum, const char *msg); // idb
void __cdecl _RTC_UninitUse(const char *varname); // idb
int __cdecl _vsprintf_s_l(char *const _Buffer, const unsigned int _BufferCount, const char *const _Format, __crt_locale_pointers *const _Locale, char *_ArgList); // idb
int sprintf_s(char *const _Buffer, const unsigned int _BufferCount, const char *const _Format, ...); // idb
int __cdecl pre_c_initialization(); // idb
int __cdecl post_pgo_initialization(); // idb
int pre_cpp_initialization();
int __cdecl _scrt_common_main(); // idb
int __cdecl _scrt_common_main_seh(); // idb
int __cdecl __scrt_narrow_argv_policy::configure_argv(); // idb
signed int __cdecl __scrt_main_policy::get_app_type();
int initialize_environment();
int __cdecl invoke_main(); // idb
int __cdecl mainCRTStartup(); // idb
void __thiscall std::bad_alloc::bad_alloc(std::bad_alloc *this, const char *const _Message); // idb
void __thiscall std::bad_alloc::bad_alloc(std::bad_alloc *this, std::bad_alloc *__that); // idb
void __thiscall std::bad_alloc::bad_alloc(std::bad_alloc *this); // idb
void __thiscall std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this, std::bad_array_new_length *__that); // idb
void __thiscall std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this); // idb
void __thiscall std::exception::exception(std::exception *this, std::exception *_Other); // idb
void __thiscall std::exception::exception(std::exception *this, const char *const _Message, int __formal); // idb
void __thiscall std::bad_alloc::~bad_alloc(std::bad_alloc *this); // idb
void __thiscall std::bad_array_new_length::~bad_array_new_length(std::bad_array_new_length *this); // idb
void __thiscall std::exception::~exception(std::exception *this); // idb
std::bad_alloc *__thiscall std::bad_alloc::`vector deleting destructor'(std::bad_alloc *this, unsigned int a2);
std::bad_array_new_length *__thiscall std::bad_array_new_length::`scalar deleting destructor'(std::bad_array_new_length *this, unsigned int a2);
std::exception *__thiscall std::exception::`scalar deleting destructor'(std::exception *this, unsigned int a2);
void __cdecl __noreturn __scrt_throw_std_bad_alloc();
void __cdecl __noreturn __scrt_throw_std_bad_array_new_length();
const char *__thiscall std::exception::what(std::exception *this); // idb
void __cdecl operator delete(void *block); // idb
void __cdecl __raise_securityfailure(_EXCEPTION_POINTERS *const exception_pointers); // idb
// void __usercall __noreturn __report_gsfailure(unsigned int a1@<ebx>, unsigned int a2@<edi>, unsigned int a3@<esi>, char a4);
void __report_rangecheckfailure();
// void __usercall __report_securityfailure(unsigned int a1@<ebx>, unsigned int a2@<edi>, unsigned int a3@<esi>, unsigned int failure_code);
// void __usercall __report_securityfailureEx(unsigned int a1@<ebx>, unsigned int a2@<edi>, unsigned int a3@<esi>, unsigned int failure_code, unsigned int parameter_count, void **parameters);
int (*__cdecl _RTC_GetErrorFunc())(int, const char *, int, const char *, const char *, ...);
int (*__cdecl _RTC_GetErrorFuncW())(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...);
const char *__cdecl _RTC_GetErrDesc(_RTC_ErrorNumber errnum); // idb
int __cdecl _RTC_NumErrors(); // idb
int (*__cdecl _RTC_SetErrorFunc(int (*func)(int, const char *, int, const char *, const char *, ...)))(int, const char *, int, const char *, const char *, ...); // idb
int (*__cdecl _RTC_SetErrorFuncW(int (*func)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...)))(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...); // idb
int __cdecl _RTC_SetErrorType(_RTC_ErrorNumber errnum, int type); // idb
HINSTANCE__ *__cdecl GetPdbDll(); // idb
HINSTANCE__ *__cdecl GetPdbDllFromInstallPath(); // idb
int __cdecl GetPdbDllPathFromFilePath(const wchar_t *sourcePath, wchar_t *pdbDllPath, unsigned int pdbDllPathSize); // idb
int __cdecl _RTC_GetSrcLine(char *address, wchar_t *source, unsigned int sourcelen, int *pline, wchar_t *moduleName, unsigned int modulelen); // idb
void __fastcall _guard_check_icall(unsigned int Target); // idb
int __cdecl _except_handler4(_EXCEPTION_RECORD *ExceptionRecord, _EXCEPTION_REGISTRATION_RECORD *EstablisherFrame, _CONTEXT *ContextRecord, void *DispatcherContext);
void (__cdecl **__cdecl __crt_fast_decode_pointer<void (__cdecl **)(void)>(void (__cdecl **const p)()))(); // idb
void (__cdecl **__cdecl __crt_fast_encode_pointer<void (__cdecl **)(void)>(void (__cdecl **const p)()))(); // idb
unsigned int __cdecl __crt_rotate_pointer_value(const unsigned int value, const int shift); // idb
_IMAGE_SECTION_HEADER *__cdecl find_pe_section(char *const image_base, const unsigned int rva); // idb
bool __cdecl is_potentially_valid_image_base(void *const image_base); // idb
_TEB *__cdecl NtCurrentTeb(); // idb
char __cdecl __scrt_acquire_startup_lock();
char __cdecl __scrt_dllmain_after_initialize_c();
bool __cdecl __scrt_dllmain_before_initialize_c(); // idb
char __cdecl __scrt_dllmain_crt_thread_attach();
char __cdecl __scrt_dllmain_crt_thread_detach();
int __cdecl __scrt_dllmain_exception_filter(HINSTANCE__ *instance, unsigned int reason, void *reserved, int (__stdcall *crt_dllmain)(HINSTANCE__ *, unsigned int, void *), unsigned int exception_code_, _EXCEPTION_POINTERS *exception_info_); // idb
void __scrt_dllmain_uninitialize_c();
bool __scrt_dllmain_uninitialize_critical();
char __cdecl __scrt_initialize_crt(__scrt_module_type module_type);
bool __cdecl __scrt_initialize_onexit_tables(__scrt_module_type module_type); // idb
bool __cdecl __scrt_is_nonwritable_in_current_image(const void *target); // idb
void __cdecl __scrt_release_startup_lock(bool is_nested); // idb
char __cdecl __scrt_uninitialize_crt(bool is_terminating, bool from_exit);
int (__cdecl *__cdecl _onexit(int (__cdecl *function)()))(); // idb
int __cdecl at_quick_exit(void (__cdecl *function)()); // idb
int __cdecl atexit(void (__cdecl *function)()); // idb
unsigned int __security_init_cookie();
int __cdecl _matherr();
signed int __cdecl _get_startup_argv_mode();
int __cdecl _get_startup_commit_mode(); // idb
int __cdecl _get_startup_file_mode(); // idb
int __cdecl _get_startup_new_mode(); // idb
int __cdecl _get_startup_thread_locale_mode(); // idb
void __cdecl __scrt_initialize_type_info(); // idb
void __cdecl __scrt_uninitialize_type_info(); // idb
char __cdecl _should_initialize_environment();
void _initialize_default_precision();
void _initialize_invalid_parameter_handler();
void _initialize_denormal_control();
unsigned __int64 *__cdecl __local_stdio_scanf_options(); // idb
int __scrt_initialize_default_local_stdio_options();
BOOL __scrt_is_user_matherr_present();
void *__scrt_get_dyn_tls_init_callback();
void *__scrt_get_dyn_tls_dtor_callback();
// void __usercall __scrt_fastfail(unsigned int a1@<ebx>, unsigned int a2@<edi>, unsigned int a3@<esi>, unsigned int code);
unsigned __int16 __cdecl __scrt_get_show_window_mode(); // idb
int __cdecl __scrt_initialize_winrt(); // idb
bool __cdecl __scrt_is_managed_app(); // idb
LPTOP_LEVEL_EXCEPTION_FILTER __scrt_set_unhandled_exception_filter();
int __stdcall __scrt_unhandled_exception_filter(_EXCEPTION_POINTERS *const pointers); // idb
void __cdecl _crt_debugger_hook();
void *_RTC_Initialize();
void *_RTC_Terminate();
void __thiscall type_info::~type_info(type_info *this); // idb
type_info *__thiscall type_info::`scalar deleting destructor'(type_info *this, unsigned int a2);
void _guard_check_icall_nop();
int __cdecl _guard_icall_checks_enforced(); // idb
int __isa_available_init();
BOOL __scrt_is_ucrt_dll_in_use();
// size_t __cdecl strlen(const char *Str);
// void *__cdecl malloc(size_t Size);
char __cdecl __scrt_stub_for_acrt_initialize();
char __cdecl __vcrt_thread_attach();
char __cdecl __acrt_thread_detach();
char __cdecl __acrt_uninitialize();
char __cdecl __acrt_uninitialize_critical();
int __cdecl _is_c_termination_complete(); // idb
// void __usercall _unwindfunclet_____6U__char_traits_D_std___std__YAAAV__basic_ostream_DU__char_traits_D_std___0_AAV10_PBD_Z_2(int a1@<ebp>);
// void __usercall _unwindfunclet___0sentry___basic_ostream_DU__char_traits_D_std___std__QAE_AAV12__Z_0(int a1@<ebp>);
// BOOL __stdcall ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus);
// BOOL __stdcall WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds);
// BOOL __stdcall DebugActiveProcess(DWORD dwProcessId);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// DWORD __stdcall GetLastError();
// HANDLE __stdcall OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId);
// DWORD __stdcall SuspendThread(HANDLE hThread);
// DWORD __stdcall ResumeThread(HANDLE hThread);
// DWORD __stdcall GetPriorityClass(HANDLE hProcess);
// BOOL __stdcall GetThreadContext(HANDLE hThread, LPCONTEXT lpContext);
// BOOL __stdcall SetThreadContext(HANDLE hThread, const CONTEXT *lpContext);
// HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// BOOL __stdcall ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
// BOOL __stdcall DebugSetProcessKillOnExit(BOOL KillOnExit);
// void __stdcall GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo);
// void __stdcall InitializeSListHead(PSLIST_HEADER ListHead);
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// DWORD __stdcall GetCurrentThreadId();
// DWORD __stdcall GetCurrentProcessId();
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// HANDLE __stdcall GetProcessHeap();
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// HANDLE __stdcall GetCurrentProcess();
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// BOOL __stdcall IsDebuggerPresent();
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
// bool __cdecl std::uncaught_exception(); weak
// int __thiscall std::basic_istream<char,std::char_traits<char>>::operator>>(_DWORD, _DWORD); weak
// int __thiscall std::basic_ostream<char,std::char_traits<char>>::flush(_DWORD); weak
// int __thiscall std::basic_ostream<char,std::char_traits<char>>::operator<<(_DWORD, _DWORD); weak
// int __thiscall std::basic_ostream<char,std::char_traits<char>>::_Osfx(_DWORD); weak
// bool __thiscall std::ios_base::good(std::ios_base *__hidden this); weak
// _DWORD __thiscall std::ios_base::flags(std::ios_base *__hidden this); weak
// __int64 __thiscall std::ios_base::width(std::ios_base *__hidden this); weak
// __int64 __thiscall std::ios_base::width(std::ios_base *__hidden this, __int64); weak
// int __thiscall std::basic_streambuf<char,std::char_traits<char>>::sputc(_DWORD, _DWORD); weak
// int __thiscall std::basic_streambuf<char,std::char_traits<char>>::sputn(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __thiscall std::basic_ios<char,std::char_traits<char>>::setstate(_DWORD, _DWORD); weak
// int __thiscall std::basic_ios<char,std::char_traits<char>>::fill(_DWORD); weak
// int __thiscall std::basic_ios<char,std::char_traits<char>>::tie(_DWORD); weak
// int __thiscall std::basic_ios<char,std::char_traits<char>>::rdbuf(_DWORD); weak
// int __cdecl ___stdio_common_vfprintf(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl ___acrt_iob_func(_DWORD); weak
// int __cdecl _atoi(const char *Str);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN j___CrtDbgReport; // weak
_UNKNOWN j___CrtDbgReportW; // weak
const char *const RTC_ErrorMessages[6] =
{
  "The value of ESP was not properly saved across a function call.  This is usually a result of calling a function declared with one calling convention with a function pointer declared with a different calling convention.\n\r",
  "A cast to a smaller data type has caused a loss of data.  If this was intentional, you should mask the source of the cast with the appropriate bitmask.  For example:  \n\r\tchar c = (i & 0xFF);\n\rChanging the code in this way will not affect the quality of the resulting optimized code.\n\r",
  "Stack memory was corrupted\n\r",
  "A local variable was used before it was initialized\n\r",
  "Stack memory around _alloca was corrupted\n\r",
  "Unknown Runtime Check Error\n\r"
}; // idb
const int RTC_NoFalsePositives[6] = { 1, 0, 1, 1, 1, 1 }; // idb
char stack_premsg[28] = "Stack around the variable '"; // idb
char uninit_premsg[15] = "The variable '"; // idb
void *(__thiscall *std::exception::`vftable')(std::exception *this, unsigned int) = &std::exception::`scalar deleting destructor'; // weak
void *(__thiscall *std::bad_alloc::`vftable')(std::bad_alloc *this, unsigned int) = &std::bad_alloc::`vector deleting destructor'; // weak
void *(__thiscall *std::bad_array_new_length::`vftable')(std::bad_array_new_length *this, unsigned int) = &std::bad_array_new_length::`scalar deleting destructor'; // weak
_EXCEPTION_POINTERS GS_ExceptionPointers = { &GS_ExceptionRecord, &GS_ContextRecord }; // idb
const char *const RTC_errlist[5] =
{
  "Stack pointer corruption",
  "Cast to smaller type causing loss of data",
  "Stack memory corruption",
  "Local variable used before initialization",
  "Stack around _alloca corrupted"
}; // idb
const wchar_t mspdbName[17] =
{
  98u,
  105u,
  110u,
  92u,
  77u,
  83u,
  80u,
  68u,
  66u,
  49u,
  52u,
  48u,
  46u,
  68u,
  76u,
  76u,
  0u
}; // idb
const wchar_t debugCrtFileName[18] =
{
  86u,
  67u,
  82u,
  85u,
  78u,
  84u,
  73u,
  77u,
  69u,
  49u,
  52u,
  48u,
  68u,
  46u,
  100u,
  108u,
  108u,
  0u
}; // idb
void *(__thiscall *type_info::`vftable')(type_info *this, unsigned int) = &type_info::`scalar deleting destructor'; // weak
_UNKNOWN unk_41ACB0; // weak
_UNKNOWN __rtc_izz; // weak
_UNKNOWN unk_41AFBC; // weak
_UNKNOWN __rtc_tzz; // weak
_UNKNOWN _TI2_AVbad_alloc_std__; // weak
_UNKNOWN _TI3_AVbad_array_new_length_std__; // weak
char FirstOffsetPattern[17] = "U‹ìƒ=ªªªªªV‹u\bªªƒ"; // idb
char SecondOffsetPattern[3] = "U‹ì"; // idb
int _RTC_ErrorLevels = 1; // idb
int dword_41C030 = 1; // weak
int dword_41C034 = 1; // weak
int crttype = 1; // idb
int __security_cookie_complement = 1153374641; // weak
int __security_cookie = 3141592654; // weak
int __scrt_default_matherr = 1; // weak
int __isa_enabled = 1; // weak
int __scrt_ucrt_dll_is_in_use = 1; // weak
HANDLE hThread = NULL; // idb
void *hProcess; // idb
unsigned __int32 WowModule_Start; // weak
unsigned __int32 WowModule_End; // weak
unsigned __int32 numberOfThreads; // weak
unsigned __int64 `__local_stdio_printf_options'::`2'::_OptionsStorage; // idb
bool init; // idb
_EXCEPTION_RECORD GS_ExceptionRecord; // idb
_CONTEXT GS_ContextRecord; // idb
int (*RTC_ErrorReportFunc)(int, const char *, int, const char *, const char *, ...); // idb
int (*RTC_ErrorReportFuncW)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...); // idb
HINSTANCE__ *mspdb; // idb
bool alreadyTried; // idb
bool PDBOK; // idb
_UNKNOWN __scrt_native_startup_lock; // weak
_onexit_table_t module_local_atexit_table; // idb
_onexit_table_t module_local_at_quick_exit_table; // idb
bool is_initialized_as_dll; // idb
_SLIST_HEADER __type_info_root_node; // idb
unsigned __int64 `__local_stdio_scanf_options'::`2'::_OptionsStorage; // idb
int __scrt_debugger_hook_flag; // weak
int __isa_available; // weak
int __favor; // weak
_UNKNOWN __dyn_tls_dtor_callback; // weak
_UNKNOWN __dyn_tls_init_callback; // weak
// extern std::basic_ostream<char,std::char_traits<char> > *std::cout; idb
// extern _UNKNOWN std::cin; weak
int (__cdecl *__guard_check_icall_fptr)(_DWORD) = &_guard_check_icall_nop; // weak


//----- (004119F0) --------------------------------------------------------
unsigned __int64 __cdecl std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char> > *_Ostr, const char *_Val)
{
  __int64 v2; // rax@1
  __int64 v3; // rax@5
  int v4; // eax@17
  __int64 v5; // rax@17
  unsigned int v6; // edx@27
  int v8; // [sp-8h] [bp-174h]@1
  unsigned int v9; // [sp-8h] [bp-174h]@26
  unsigned int v10; // [sp-4h] [bp-170h]@1
  __int64 v11; // [sp+Ch] [bp-160h]@1
  __int64 v12; // [sp+14h] [bp-158h]@4
  __int64 v13; // [sp+1Ch] [bp-150h]@1
  std::basic_ostream<char,std::char_traits<char> > *v14; // [sp+28h] [bp-144h]@27
  int v15; // [sp+34h] [bp-138h]@23
  int v16; // [sp+40h] [bp-12Ch]@23
  int _Left; // [sp+4Ch] [bp-120h]@13
  int _Right; // [sp+58h] [bp-114h]@13
  std::basic_ostream<char,std::char_traits<char> >::sentry _Ok; // [sp+124h] [bp-48h]@7
  __int64 _Pad; // [sp+134h] [bp-38h]@7
  __int64 _Count; // [sp+144h] [bp-28h]@1
  int _State; // [sp+154h] [bp-18h]@1
  unsigned int *v23; // [sp+15Ch] [bp-10h]@1
  int v24; // [sp+168h] [bp-4h]@7
  int savedregs; // [sp+16Ch] [bp+0h]@1

  memset(&v11, 0xCCu, 0x150u);
  v10 = (unsigned int)&savedregs ^ __security_cookie;
  v23 = &v10;
  _State = 0;
  _Count = std::char_traits<char>::length(_Val);
  v2 = std::ios_base::width((std::ios_base *)((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4)));
  v13 = v2;
  if ( SHIDWORD(v2) >= 0
    && (SHIDWORD(v2) > 0 || (_DWORD)v13)
    && (v12 = std::ios_base::width((std::ios_base *)((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4))),
        v12 > _Count) )
  {
    v3 = std::ios_base::width((std::ios_base *)((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4)));
    v11 = v3 - _Count;
  }
  else
  {
    _mm_storel_pd((double *)&v11, 0i64);
  }
  _Pad = v11;
  std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(&_Ok, _Ostr);
  v24 = 0;
  if ( std::basic_ostream<char,std::char_traits<char>>::sentry::operator bool(&_Ok) )
  {
    LOBYTE(v24) = 1;
    HIDWORD(v13) = std::ios_base::flags((std::ios_base *)((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4)));
    if ( (WORD2(v13) & 0x1C0) != 64 )
    {
      while ( SHIDWORD(_Pad) >= 0 && (SHIDWORD(_Pad) > 0 || (_DWORD)_Pad) )
      {
        BYTE7(v13) = std::basic_ios<char,std::char_traits<char>>::fill((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0]
                                                                                                 + 4));
        LODWORD(v13) = std::basic_ios<char,std::char_traits<char>>::rdbuf((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4));
        HIDWORD(v12) = std::basic_streambuf<char,std::char_traits<char>>::sputc(v13, BYTE7(v13));
        _Right = HIDWORD(v12);
        _Left = std::char_traits<char>::eof();
        if ( std::char_traits<char>::eq_int_type(&_Left, &_Right) )
        {
          _State |= 4u;
          break;
        }
        --_Pad;
      }
    }
    if ( !_State )
    {
      v4 = std::basic_ios<char,std::char_traits<char>>::rdbuf((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4));
      HIDWORD(v13) = v4;
      LODWORD(v5) = std::basic_streambuf<char,std::char_traits<char>>::sputn(v4, _Val, v8, HIDWORD(_Count));
      *(__int64 *)((char *)&v12 + 4) = v5;
      if ( v5 != _Count )
        _State |= 4u;
    }
    if ( !_State )
    {
      while ( SHIDWORD(_Pad) >= 0 && (SHIDWORD(_Pad) > 0 || (_DWORD)_Pad) )
      {
        BYTE7(v13) = std::basic_ios<char,std::char_traits<char>>::fill((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0]
                                                                                                 + 4));
        LODWORD(v13) = std::basic_ios<char,std::char_traits<char>>::rdbuf((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4));
        HIDWORD(v12) = std::basic_streambuf<char,std::char_traits<char>>::sputc(v13, BYTE7(v13));
        v16 = HIDWORD(v12);
        v15 = std::char_traits<char>::eof();
        if ( std::char_traits<char>::eq_int_type(&v15, &v16) )
        {
          _State |= 4u;
          break;
        }
        --_Pad;
      }
    }
    v10 = 0;
    std::ios_base::width((std::ios_base *)((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4)), v9);
    v24 = 0;
  }
  else
  {
    _State |= 4u;
  }
  v10 = 0;
  std::basic_ios<char,std::char_traits<char>>::setstate(
    (char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4),
    _State);
  v14 = _Ostr;
  v24 = -1;
  std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(&_Ok);
  return __PAIR__(v6, (unsigned int)v14);
}
// 41D114: using guessed type _DWORD __thiscall std::ios_base::flags(std::ios_base *__hidden this);
// 41D118: using guessed type __int64 __thiscall std::ios_base::width(std::ios_base *__hidden this);
// 41D11C: using guessed type __int64 __thiscall std::ios_base::width(std::ios_base *__hidden this, __int64);
// 41D120: using guessed type int __thiscall std::basic_streambuf<char,std::char_traits<char>>::sputc(_DWORD, _DWORD);
// 41D124: using guessed type int __thiscall std::basic_streambuf<char,std::char_traits<char>>::sputn(_DWORD, _DWORD, _DWORD, _DWORD);
// 41D128: using guessed type int __thiscall std::basic_ios<char,std::char_traits<char>>::setstate(_DWORD, _DWORD);
// 41D12C: using guessed type int __thiscall std::basic_ios<char,std::char_traits<char>>::fill(_DWORD);
// 41D134: using guessed type int __thiscall std::basic_ios<char,std::char_traits<char>>::rdbuf(_DWORD);

//----- (00411FB0) --------------------------------------------------------
signed int __vcrt_va_start_verify_argument_type<char const * const>()
{
  return -858993460;
}

//----- (00411FE0) --------------------------------------------------------
void __thiscall std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(std::basic_ostream<char,std::char_traits<char> >::_Sentry_base *this, std::basic_ostream<char,std::char_traits<char> > *_Ostr)
{
  int v2; // [sp+Ch] [bp-D4h]@1
  std::basic_ostream<char,std::char_traits<char> > *v3; // [sp+10h] [bp-D0h]@1
  std::basic_ostream<char,std::char_traits<char> >::_Sentry_base *const thisa; // [sp+D8h] [bp-8h]@1

  memset(&v2, 0xCCu, 0xD4u);
  thisa = this;
  this->_Myostr = _Ostr;
  v3 = thisa->_Myostr;
  if ( std::basic_ios<char,std::char_traits<char>>::rdbuf((char *)v3 + *(_DWORD *)(*(_DWORD *)&v3->gap0[0] + 4)) )
  {
    v3 = thisa->_Myostr;
    v2 = std::basic_ios<char,std::char_traits<char>>::rdbuf((char *)v3 + *(_DWORD *)(*(_DWORD *)&v3->gap0[0] + 4));
    (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
  }
}
// 41D134: using guessed type int __thiscall std::basic_ios<char,std::char_traits<char>>::rdbuf(_DWORD);

//----- (004120D0) --------------------------------------------------------
void __thiscall std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char> >::sentry *this, std::basic_ostream<char,std::char_traits<char> > *_Ostr)
{
  int v2; // eax@4
  unsigned int v3; // [sp-4h] [bp-E8h]@1
  char v4; // [sp+Ch] [bp-D8h]@1
  std::basic_ostream<char,std::char_traits<char> >::sentry *const thisa; // [sp+D0h] [bp-14h]@1
  int v6; // [sp+E0h] [bp-4h]@1
  int savedregs; // [sp+E4h] [bp+0h]@1

  memset(&v4, 0xCCu, 0xCCu);
  v3 = (unsigned int)&savedregs ^ __security_cookie;
  thisa = this;
  std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(
    (std::basic_ostream<char,std::char_traits<char> >::_Sentry_base *)&this->_Myostr,
    _Ostr);
  v6 = 0;
  if ( std::ios_base::good((std::ios_base *)((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4)))
    && std::basic_ios<char,std::char_traits<char>>::tie((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4))
    && (std::basic_ostream<char,std::char_traits<char> > *)std::basic_ios<char,std::char_traits<char>>::tie((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4)) != _Ostr )
  {
    v2 = std::basic_ios<char,std::char_traits<char>>::tie((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4));
    std::basic_ostream<char,std::char_traits<char>>::flush(v2);
  }
  thisa->_Ok = std::ios_base::good((std::ios_base *)((char *)_Ostr + *(_DWORD *)(*(_DWORD *)&_Ostr->gap0[0] + 4)));
}
// 41D104: using guessed type int __thiscall std::basic_ostream<char,std::char_traits<char>>::flush(_DWORD);
// 41D110: using guessed type bool __thiscall std::ios_base::good(std::ios_base *__hidden this);
// 41D130: using guessed type int __thiscall std::basic_ios<char,std::char_traits<char>>::tie(_DWORD);

//----- (00412250) --------------------------------------------------------
void __thiscall std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(std::basic_ostream<char,std::char_traits<char> >::_Sentry_base *this)
{
  unsigned int v1; // [sp-4h] [bp-F0h]@1
  int v2; // [sp+Ch] [bp-E0h]@1
  std::basic_ostream<char,std::char_traits<char> > *v3; // [sp+10h] [bp-DCh]@1
  std::basic_ostream<char,std::char_traits<char> >::_Sentry_base *const thisa; // [sp+D8h] [bp-14h]@1
  int savedregs; // [sp+ECh] [bp+0h]@1

  memset(&v2, 0xCCu, 0xD4u);
  v1 = (unsigned int)&savedregs ^ __security_cookie;
  thisa = this;
  v3 = this->_Myostr;
  if ( std::basic_ios<char,std::char_traits<char>>::rdbuf((char *)v3 + *(_DWORD *)(*(_DWORD *)&v3->gap0[0] + 4)) )
  {
    v3 = thisa->_Myostr;
    v2 = std::basic_ios<char,std::char_traits<char>>::rdbuf((char *)v3 + *(_DWORD *)(*(_DWORD *)&v3->gap0[0] + 4));
    (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 8))(v2);
  }
}
// 41D134: using guessed type int __thiscall std::basic_ios<char,std::char_traits<char>>::rdbuf(_DWORD);

//----- (00412370) --------------------------------------------------------
void __thiscall std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(std::basic_ostream<char,std::char_traits<char> >::sentry *this)
{
  unsigned int v1; // [sp-4h] [bp-E8h]@1
  char v2; // [sp+Ch] [bp-D8h]@1
  std::basic_ostream<char,std::char_traits<char> >::sentry *const thisa; // [sp+D0h] [bp-14h]@1
  int savedregs; // [sp+E4h] [bp+0h]@1

  memset(&v2, 0xCCu, 0xCCu);
  v1 = (unsigned int)&savedregs ^ __security_cookie;
  thisa = this;
  if ( !std::uncaught_exception() )
    std::basic_ostream<char,std::char_traits<char>>::_Osfx(thisa->_Myostr);
  std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base((std::basic_ostream<char,std::char_traits<char> >::_Sentry_base *)&thisa->_Myostr);
}
// 41D0F4: using guessed type bool __cdecl std::uncaught_exception();
// 41D10C: using guessed type int __thiscall std::basic_ostream<char,std::char_traits<char>>::_Osfx(_DWORD);

//----- (00412430) --------------------------------------------------------
bool __thiscall std::basic_ostream<char,std::char_traits<char>>::sentry::operator bool(std::basic_ostream<char,std::char_traits<char> >::sentry *this)
{
  char v2; // [sp+Ch] [bp-CCh]@1
  std::basic_ostream<char,std::char_traits<char> >::sentry *const thisa; // [sp+D0h] [bp-8h]@1

  memset(&v2, 0xCCu, 0xCCu);
  thisa = this;
  return this->_Ok;
}

//----- (00412470) --------------------------------------------------------
char __cdecl CheckPattern(const char *mask, char *buffer, char *pattern, unsigned int length)
{
  char v5; // [sp+Ch] [bp-CCh]@1
  unsigned int i; // [sp+D0h] [bp-8h]@1

  memset(&v5, 0xCCu, 0xCCu);
  i = 0;
  do
  {
    if ( mask[i] != 63 && (unsigned __int8)buffer[i] != (unsigned __int8)pattern[i] )
      return 0;
    ++i;
  }
  while ( i < length );
  return 1;
}

//----- (004124F0) --------------------------------------------------------
int __cdecl FillProcessList(unsigned int *processList)
{
  int result; // eax@2
  char v2; // [sp+Ch] [bp-218h]@1
  tagPROCESSENTRY32 pe; // [sp+D0h] [bp-154h]@3
  unsigned int i; // [sp+200h] [bp-24h]@5
  void *v4; // [sp+20Ch] [bp-18h]@6
  void *pSnapshot; // [sp+218h] [bp-Ch]@1
  unsigned int v7; // [sp+220h] [bp-4h]@1
  int savedregs; // [sp+224h] [bp+0h]@1

  memset(&v2, 0xCCu, 0x218u);
  v7 = (unsigned int)&savedregs ^ __security_cookie;
  pSnapshot = CreateToolhelp32Snapshot(2u, 0);
  if ( pSnapshot == (void *)-1 )
  {
    result = 0;
  }
  else
  {
    pe.dwSize = 296;
    if ( Process32First(pSnapshot, &pe) )
    {
      i = 0;
      do
      {
        v4 = OpenProcess(0x1FFFFFu, 0, pe.th32ProcessID);
        GetPriorityClass(v4);
        CloseHandle(v4);
        if ( !j__strcmp(pe.szExeFile, "Wow.exe") )
          processList[i++] = pe.th32ProcessID;
      }
      while ( Process32Next(pSnapshot, &pe) );
      CloseHandle(pSnapshot);
      result = 1;
    }
    else
    {
      CloseHandle(pSnapshot);
      result = 0;
    }
  }
  return result;
}

//----- (004126C0) --------------------------------------------------------
unsigned int __cdecl FindOffset(void *hProcess, char *pattern, const char *mask, unsigned int baseStart, unsigned int baseEnd)
{
  char v6; // [sp+Ch] [bp-FCh]@1
  void *block; // [sp+10h] [bp-F8h]@8
  unsigned int i; // [sp+DCh] [bp-2Ch]@1
  unsigned int NumberOfBytesRead; // [sp+E8h] [bp-20h]@4
  char *buffer; // [sp+F4h] [bp-14h]@1
  unsigned int patternLength; // [sp+100h] [bp-8h]@1

  memset(&v6, 0xCCu, 0xFCu);
  patternLength = j__strlen(mask);
  buffer = (char *)operator new(patternLength + 1);
  for ( i = baseStart;
        i < baseEnd - patternLength
     && ReadProcessMemory(hProcess, (LPCVOID)i, buffer, patternLength, &NumberOfBytesRead) > 0
     && NumberOfBytesRead;
        ++i )
  {
    if ( CheckPattern(mask, buffer, pattern, patternLength) )
      return i;
  }
  block = buffer;
  operator delete(buffer, 1u);
  return 0;
}

//----- (00412830) --------------------------------------------------------
unsigned __int64 __cdecl GetNumberOfThreads(int processId)
{
  unsigned int v1; // edx@1
  char v3; // [sp+Ch] [bp-100h]@1
  tagTHREADENTRY32 te; // [sp+D0h] [bp-3Ch]@1
  int v2; // [sp+F4h] [bp-18h]@1
  void *threadSnapshot; // [sp+100h] [bp-Ch]@1
  unsigned int v7; // [sp+108h] [bp-4h]@1
  int savedregs; // [sp+10Ch] [bp+0h]@1

  memset(&v3, 0xCCu, 0x100u);
  v7 = (unsigned int)&savedregs ^ __security_cookie;
  te.dwSize = 28;
  te.cntUsage = 0;
  te.th32ThreadID = 0;
  te.th32OwnerProcessID = 0;
  te.tpBasePri = 0;
  te.tpDeltaPri = 0;
  te.dwFlags = 0;
  threadSnapshot = CreateToolhelp32Snapshot(4u, 0);
  v2 = 0;
  if ( Thread32First(threadSnapshot, &te) && Thread32Next(threadSnapshot, &te) )
  {
    do
    {
      if ( te.th32OwnerProcessID == processId )
      {
        *(&hThread + v2++) = OpenThread(0x1FFFFFu, 0, te.th32ThreadID);
        ++numberOfThreads;
      }
    }
    while ( Thread32Next(threadSnapshot, &te) );
  }
  return __PAIR__(v1, v2);
}
// 41C49C: using guessed type unsigned __int32 numberOfThreads;

//----- (004129B0) --------------------------------------------------------
void __cdecl __empty_global_delete()
{
  ;
}

//----- (004129E0) --------------------------------------------------------
void __cdecl __empty_global_delete()
{
  ;
}

//----- (00412A10) --------------------------------------------------------
int __cdecl std::char_traits<char>::eof()
{
  return -1;
}

//----- (00412A50) --------------------------------------------------------
bool __cdecl std::char_traits<char>::eq_int_type(const int *_Left, const int *_Right)
{
  int v3; // [sp+Ch] [bp-C4h]@1

  memset(&v3, 0xCCu, 0xC4u);
  return *_Left == *_Right;
}

//----- (00412AB0) --------------------------------------------------------
unsigned int __cdecl std::char_traits<char>::length(const char *_First)
{
  size_t v2; // [sp+Ch] [bp-C4h]@1

  memset(&v2, 0xCCu, 0xC4u);
  if ( *_First )
    v2 = j__strlen(_First);
  else
    v2 = 0;
  return v2;
}

//----- (00412B30) --------------------------------------------------------
unsigned __int64 *__cdecl __local_stdio_printf_options()
{
  return &`__local_stdio_printf_options'::`2'::_OptionsStorage;
}

//----- (00412B70) --------------------------------------------------------
int __cdecl _vfprintf_l(_iobuf *const _Stream, const char *const _Format, __crt_locale_pointers *const _Locale, char *_ArgList)
{
  unsigned __int64 *v4; // eax@1
  char v6; // [sp+Ch] [bp-C0h]@1

  memset(&v6, 0xCCu, 0xC0u);
  v4 = j____local_stdio_printf_options();
  return ___stdio_common_vfprintf(*(_DWORD *)v4, *((_DWORD *)v4 + 1), _Stream, _Format, _Locale, _ArgList);
}
// 41D254: using guessed type int __cdecl ___stdio_common_vfprintf(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00412BF0) --------------------------------------------------------
void __cdecl main(int argc, const char **argv)
{
  DWORD v2; // ST10_4@12
  std::basic_ostream<char,std::char_traits<char> > *eax12; // eax@12
  char varAB8; // [sp+Ch] [bp-AB8h]@1
  char v5; // [sp+13h] [bp-AB1h]@1
  void *p; // [sp+31Ch] [bp-7A8h]@9
  unsigned int test2; // [sp+328h] [bp-79Ch]@9
  unsigned int test1; // [sp+334h] [bp-790h]@9
  unsigned int dwProcessId; // [sp+340h] [bp-784h]@1
  unsigned int processList[100]; // [sp+34Ch] [bp-778h]@1
  _CONTEXT Context; // [sp+4E4h] [bp-5E0h]@3
  tagMODULEENTRY32 moduleEntry; // [sp+7B8h] [bp-30Ch]@9
  _DEBUG_EVENT DebugEvent; // [sp+9E4h] [bp-E0h]@14
  unsigned int FirstOffsetAddress; // [sp+A4Ch] [bp-78h]@9
  unsigned int SecondOffsetAddress; // [sp+A58h] [bp-6Ch]@9
  unsigned int ThirdOffsetAddress; // [sp+A64h] [bp-60h]@21
  int enterredNumber; // [sp+A70h] [bp-54h]@1
  void *v8; // [sp+A7Ch] [bp-48h]@16
  void *v7; // [sp+A88h] [bp-3Ch]@10
  unsigned int v6; // [sp+A94h] [bp-30h]@9
  void *modulesSnapshot; // [sp+AA0h] [bp-24h]@9
  unsigned int v4; // [sp+AACh] [bp-18h]@9
  int v3; // [sp+AB8h] [bp-Ch]@4
  unsigned int v24; // [sp+AC0h] [bp-4h]@1
  int savedregs; // [sp+AC4h] [bp+0h]@1

  memset(&varAB8, 0xCCu, 0xAB8u);
  v24 = (unsigned int)&savedregs ^ __security_cookie;
  v5 = 0;
  processList[0] = 0;
  j__memset(&processList[1], 0, 0x18Cu);
  dwProcessId = 0;
  enterredNumber = 0;
  if ( argc > 1 )
    dwProcessId = _atoi(argv[1]);
  j__printf("Created by : DarkLinux @ ownedcore.com \n");
  j__printf("Game Version : WoW 7.0.3 \n");
  j__printf("Version : 1.4.7 \n");
  j__printf("Looking for game process..\n");
  Context.ContextFlags = 65559;
  if ( !dwProcessId )
  {
    FillProcessList(processList);
    v3 = 0;
    do
    {
      if ( processList[v3] )
        j__printf("%d:  %#x\n", v3, processList[v3]);
      ++v3;
    }
    while ( v3 < 100 );
    std::basic_istream<char,std::char_traits<char>>::operator>>(std::cin, &enterredNumber);
    dwProcessId = processList[enterredNumber];
  }
  j__printf("Process id: %d\n", dwProcessId);
  v4 = dwProcessId;
  moduleEntry.dwSize = 548;
  modulesSnapshot = CreateToolhelp32Snapshot(8u, dwProcessId);
  Module32First(modulesSnapshot, &moduleEntry);
  WowModule_Start = (unsigned __int32)moduleEntry.modBaseAddr;
  WowModule_End = (unsigned __int32)&moduleEntry.modBaseAddr[moduleEntry.modBaseSize];
  CloseHandle(modulesSnapshot);
  hProcess = OpenProcess(0x1FFFFFu, 0, v4);
  j__printf("Please do not close this window. \n");
  test1 = WowModule_Start;
  test2 = WowModule_End;
  p = hProcess;
  GetNumberOfThreads(dwProcessId);
  hProcess = p;
  std::operator<<<std::char_traits<char>>(std::cout, "\n Loading : ");
  std::operator<<<std::char_traits<char>>(std::cout, "#");
  FirstOffsetAddress = FindOffset(hProcess, FirstOffsetPattern, "xxxxx?????xxxx??xx", test1, test2) + 14;
  std::operator<<<std::char_traits<char>>(std::cout, "#");
  SecondOffsetAddress = FindOffset(hProcess, SecondOffsetPattern, "xxxxx????xx", test1, test2) + 27;
  std::operator<<<std::char_traits<char>>(std::cout, "#");
  std::operator<<<std::char_traits<char>>(std::cout, "#");
  std::operator<<<std::char_traits<char>>(std::cout, "# Done!!");
  v6 = 0;
  if ( numberOfThreads )
  {
    do
    {
      SuspendThread(*(&hThread + v6));
      GetThreadContext(*(&hThread + v6), &Context);
      Context.Dr0 = FirstOffsetAddress;
      v7 = *(&hThread + v6);
      Context.Dr7 = 1;
      SetThreadContext(v7, &Context);
      ResumeThread(*(&hThread + v6++));
    }
    while ( v6 < numberOfThreads );
  }
  if ( !DebugActiveProcess(dwProcessId) )
  {
    v2 = GetLastError();
    eax12 = std::operator<<<std::char_traits<char>>(std::cout, "\nFailed to attach debugger.");
    std::basic_ostream<char,std::char_traits<char>>::operator<<(eax12, v2);
  }
  DebugSetProcessKillOnExit(0);
  while ( 1 )
  {
    WaitForDebugEvent(&DebugEvent, 0xFFFFFFFF);
    if ( DebugEvent.u.Exception.ExceptionRecord.ExceptionCode != -2147483644 )
      goto LABEL_28;
    if ( DebugEvent.u.LoadDll.nDebugInfoSize == FirstOffsetAddress )
    {
      v8 = OpenThread(0x1FFFFFu, 0, DebugEvent.dwThreadId);
      GetThreadContext(v8, &Context);
      Context.Eip += 84;
      Context.EFlags |= 0x10040u;
      SetThreadContext(v8, &Context);
      CloseHandle(v8);
      goto LABEL_17;
    }
    if ( DebugEvent.u.LoadDll.nDebugInfoSize == SecondOffsetAddress )
    {
      v8 = OpenThread(0x1FFFFFu, 0, DebugEvent.dwThreadId);
      GetThreadContext(v8, &Context);
      Context.Eip += 73;
      Context.EFlags |= 0x10040u;
      SetThreadContext(v8, &Context);
      CloseHandle(v8);
      goto LABEL_17;
    }
    if ( !v5 )
      j___RTC_UninitUse("ThirdOffsetAddress");
    if ( DebugEvent.u.LoadDll.nDebugInfoSize == ThirdOffsetAddress )
    {
      v8 = OpenThread(0x1FFFFFu, 0, DebugEvent.dwThreadId);
      GetThreadContext(v8, &Context);
      Context.Eip += 84;
LABEL_17:
      ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, 0x10002u);
    }
    else
    {
LABEL_28:
      ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, 0x80010001);
    }
  }
}
// 41C494: using guessed type unsigned __int32 WowModule_Start;
// 41C498: using guessed type unsigned __int32 WowModule_End;
// 41C49C: using guessed type unsigned __int32 numberOfThreads;
// 41D100: using guessed type int __thiscall std::basic_istream<char,std::char_traits<char>>::operator>>(_DWORD, _DWORD);
// 41D108: using guessed type int __thiscall std::basic_ostream<char,std::char_traits<char>>::operator<<(_DWORD, _DWORD);

//----- (004134C0) --------------------------------------------------------
int printf(const char *const _Format, ...)
{
  _iobuf *v1; // eax@1
  const char *v3; // [sp-Ch] [bp-F0h]@1
  __crt_locale_pointers *v4; // [sp-8h] [bp-ECh]@1
  char *v5; // [sp-4h] [bp-E8h]@1
  char v6; // [sp+Ch] [bp-D8h]@1
  char *_ArgList; // [sp+D0h] [bp-14h]@1
  va_list va; // [sp+F0h] [bp+Ch]@1

  va_start(va, _Format);
  memset(&v6, 0xCCu, 0xD8u);
  __vcrt_va_start_verify_argument_type<char const * const>();
  _ArgList = va;
  v5 = va;
  v4 = 0;
  v3 = _Format;
  v1 = (_iobuf *)___acrt_iob_func(1);
  return j___vfprintf_l(v1, v3, v4, v5);
}
// 41129E: using guessed type int __vcrt_va_start_verify_argument_type<char const * const>(void);
// 41D258: using guessed type int __cdecl ___acrt_iob_func(_DWORD);

//----- (00413620) --------------------------------------------------------
void *__cdecl operator new(unsigned int size)
{
  void *block; // [sp+0h] [bp-4h]@1

  while ( 1 )
  {
    block = j__malloc(size);
    if ( block )
      break;
    if ( !j___callnewh(size) )
    {
      if ( size == -1 )
        __scrt_throw_std_bad_array_new_length();
      __scrt_throw_std_bad_alloc();
    }
  }
  return block;
}
// 41119A: using guessed type int __cdecl j___callnewh(_DWORD);

//----- (00413680) --------------------------------------------------------
void __cdecl operator delete(void *block)
{
  operator delete(block);
}

//----- (004136E0) --------------------------------------------------------
void __fastcall _RTC_CheckStackVars2(void *frame, _RTC_framedesc *v, _RTC_ALLOCA_NODE *allocaList)
{
  _RTC_framedesc *v3; // ebx@1
  int v4; // esi@2
  int v5; // edi@3
  _RTC_vardesc *v6; // ecx@4
  int v7; // edx@4
  _RTC_ALLOCA_NODE *v8; // esi@8
  int v9; // edi@8
  _RTC_ALLOCA_NODE *v10; // eax@8
  char *v11; // [sp+Ch] [bp-4h]@1
  void *retaddr; // [sp+14h] [bp+4h]@6

  v3 = v;
  v11 = (char *)frame;
  if ( v )
  {
    v4 = 0;
    if ( v->varCount > 0 )
    {
      v5 = 0;
      do
      {
        v6 = v3->variables;
        v7 = v6[v5].addr;
        if ( *(_DWORD *)&v11[v7 - 4] != -858993460 || *(_DWORD *)(&v11[v7] + v6[v5].size) != -858993460 )
          _RTC_StackFailure(retaddr, v6[v5].name);
        ++v4;
        ++v5;
      }
      while ( v4 < v3->varCount );
    }
  }
  v8 = allocaList;
  v9 = 0;
  v10 = allocaList;
  if ( allocaList )
  {
    do
    {
      v10 = v10->next;
      ++v9;
    }
    while ( v10 );
    if ( allocaList )
    {
      do
      {
        if ( v8->guard1 != -858993460
          || v8->guard2[0] != -858993460
          || v8->guard2[1] != -858993460
          || v8->guard2[2] != -858993460 )
        {
          _RTC_AllocaFailure(retaddr, v8, v9);
        }
        if ( *(_DWORD *)((char *)v8 + v8->allocaSize - 4) != -858993460 )
          _RTC_AllocaFailure(retaddr, v8, v9);
        v8 = v8->next;
        --v9;
      }
      while ( v8 );
    }
  }
}

//----- (004137F0) --------------------------------------------------------
void __fastcall _RTC_CheckStackVars(void *frame, _RTC_framedesc *v)
{
  _RTC_framedesc *v2; // ebx@1
  int v3; // esi@1
  int v4; // edi@2
  _RTC_vardesc *v5; // ecx@3
  int v6; // edx@3
  char *v7; // [sp+8h] [bp-4h]@1
  void *retaddr; // [sp+10h] [bp+4h]@5

  v2 = v;
  v7 = (char *)frame;
  v3 = 0;
  if ( v->varCount > 0 )
  {
    v4 = 0;
    do
    {
      v5 = v2->variables;
      v6 = v5[v4].addr;
      if ( *(_DWORD *)&v7[v6 - 4] != -858993460 || *(_DWORD *)(&v7[v6] + v5[v4].size) != -858993460 )
        _RTC_StackFailure(retaddr, v5[v4].name);
      ++v3;
      ++v4;
    }
    while ( v3 < v2->varCount );
  }
}

//----- (00413860) --------------------------------------------------------
#error "413860: can not convert to microcode (funcsize=1)"

//----- (004138C0) --------------------------------------------------------
int (*__cdecl _CRT_RTC_INIT())(int, const char *, int, const char *, const char *, ...)
{
  return (int (*)(int, const char *, int, const char *, const char *, ...))&j___CrtDbgReport;
}

//----- (004138D0) --------------------------------------------------------
int (*__cdecl _CRT_RTC_INITW())(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...)
{
  return (int (*)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...))&j___CrtDbgReportW;
}

//----- (004138E0) --------------------------------------------------------
void _RTC_InitBase()
{
  int (*v0)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...); // eax@2

  if ( !init )
  {
    init = 1;
    v0 = j___CRT_RTC_INITW(0, 0, 0, 1, 0);
    j___RTC_SetErrorFuncW(v0);
  }
}

//----- (00413920) --------------------------------------------------------
int (*_RTC_Shutdown())(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...)
{
  return j___CRT_RTC_INITW(0, 0, 0, 1, 1);
}

//----- (00413940) --------------------------------------------------------
int __cdecl DebuggerProbe(unsigned int dwLevelRequired)
{
  tagEXCEPTION_VISUALCPP_DEBUG_INFO info; // [sp+10h] [bp-34h]@1
  char bDebuggerListening; // [sp+2Bh] [bp-19h]@1
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@1

  bDebuggerListening = 0;
  info.dwType = 4097;
  *(_QWORD *)&info.SetName.szName = __PAIR__(&bDebuggerListening, dwLevelRequired);
  ms_exc.registration.TryLevel = 0;
  RaiseException(0x406D1388u, 0, 6u, &info.dwType);
  return (unsigned __int8)bDebuggerListening;
}

//----- (00413A00) --------------------------------------------------------
int __cdecl DebuggerRuntime(unsigned int dwErrorNumber, int bRealBug, void *pvReturnAddr, const wchar_t *pwMessage)
{
  tagEXCEPTION_VISUALCPP_DEBUG_INFO info; // [sp+10h] [bp-34h]@1
  char bDebuggerListening; // [sp+2Bh] [bp-19h]@1
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@1

  bDebuggerListening = 0;
  info.dwType = 4098;
  *(_QWORD *)&info.SetName.szName = __PAIR__(bRealBug, dwErrorNumber);
  *(_QWORD *)&info.RuntimeError.pvReturnAddress = __PAIR__(&bDebuggerListening, (unsigned int)pvReturnAddr);
  info.RuntimeError.pwRuntimeMessage = pwMessage;
  ms_exc.registration.TryLevel = 0;
  RaiseException(0x406D1388u, 0, 6u, &info.dwType);
  return (unsigned __int8)bDebuggerListening;
}

//----- (00413AE0) --------------------------------------------------------
void __cdecl _RTC_AllocaFailure(void *retaddr, _RTC_ALLOCA_NODE *pn, int num)
{
  int v3; // edi@1
  unsigned int v4; // ST24_4@4
  unsigned int v5; // eax@4
  char msg[244]; // [sp+Ch] [bp-140h]@4
  char valbuff[49]; // [sp+100h] [bp-4Ch]@4
  char printbuff[17]; // [sp+134h] [bp-18h]@4

  v3 = crttype;
  if ( crttype != -1 )
  {
    if ( pn )
    {
      j__sprintf_s(
        msg,
        0xF4u,
        "%s%s%p%s%zd%s%d%s",
        "Stack area around _alloca memory reserved by this function is corrupted",
        "\nAddress: 0x",
        &pn[1],
        "\nSize: ",
        pn->allocaSize - 36,
        "\nAllocation number within this function: ",
        num,
        "\nData: <");
      getMemBlockDataString(printbuff, valbuff, (char *)&pn[1], pn->allocaSize - 36);
      v4 = 244 - strlen_priv(msg);
      v5 = strlen_priv(msg);
      j__sprintf_s(&msg[v5], v4, "%s%s%s%s", printbuff, "> ", valbuff, "\n");
      failwithmessage(retaddr, v3, 4, msg);
    }
    else
    {
      failwithmessage(retaddr, crttype, 4, "Stack area around _alloca memory reserved by this function is corrupted\n");
    }
  }
}

//----- (00413C50) --------------------------------------------------------
void __cdecl _RTC_Failure(void *retaddr, int errnum)
{
  int v2; // ecx@2

  if ( (unsigned int)errnum > 4 )
  {
    failwithmessage(retaddr, 1, 5, RTC_ErrorMessages[5]);
  }
  else
  {
    v2 = *(&_RTC_ErrorLevels + errnum);
    if ( v2 != -1 )
      failwithmessage(retaddr, v2, errnum, RTC_ErrorMessages[errnum]);
  }
}

//----- (00413CC0) --------------------------------------------------------
void __cdecl _RTC_StackFailure(void *retaddr, const char *varname)
{
  const char *v2; // ebx@1
  int v3; // eax@4
  char v4; // cl@5
  char v5; // al@6
  unsigned int v6; // ebx@7
  char *v7; // edi@7
  char v8; // al@8
  unsigned int v9; // edx@9
  char *v10; // edi@9
  char v11; // al@10
  char *v12; // eax@11
  int crttype; // [sp+8h] [bp-408h]@1
  char msgB[1024]; // [sp+Ch] [bp-404h]@11

  crttype = dword_41C030;
  v2 = varname;
  if ( dword_41C030 != -1 )
  {
    if ( *varname && strlen_priv(varname) + 45 <= 0x400 )
    {
      v3 = 0;
      do
      {
        v4 = stack_premsg[v3++];
        *((_BYTE *)&crttype + v3 + 3) = v4;
      }
      while ( v4 );
      do
        v5 = *v2++;
      while ( v5 );
      v6 = v2 - varname;
      v7 = (char *)&crttype + 3;
      do
        v8 = (v7++)[1];
      while ( v8 );
      qmemcpy(v7, varname, v6);
      v9 = strlen("' was corrupted.") + 1;
      v10 = (char *)&crttype + 3;
      do
        v11 = (v10++)[1];
      while ( v11 );
      v12 = msgB;
      qmemcpy(v10, "' was corrupted.", v9);
    }
    else
    {
      v12 = "Stack corrupted near unknown variable";
    }
    failwithmessage(retaddr, crttype, 2, v12);
  }
}
// 41C030: using guessed type int dword_41C030;

//----- (00413E00) --------------------------------------------------------
void __cdecl getMemBlockDataString(char *printbuff, char *valbuff, char *data, unsigned int datasize)
{
  char *v4; // ecx@1
  unsigned int v5; // esi@1
  char *v6; // edi@1
  signed int v7; // ebx@1
  unsigned int v8; // edx@1
  unsigned int v9; // eax@2
  char v10; // bl@5
  char *v11; // [sp+Ch] [bp-8h]@2
  unsigned int v12; // [sp+10h] [bp-4h]@2
  char *dataa; // [sp+24h] [bp+10h]@1

  v4 = valbuff;
  v5 = 0;
  v6 = printbuff;
  v7 = data - printbuff;
  dataa = (char *)(data - printbuff);
  v8 = 49;
  while ( 1 )
  {
    v9 = datasize;
    v12 = v8;
    v11 = v4;
    if ( datasize >= 0x10 )
      v9 = 16;
    if ( v5 >= v9 )
      break;
    v10 = v6[v7];
    j__sprintf_s(v4, v8, "%.2X ", (unsigned __int8)v10);
    ++v5;
    *v6 = v10;
    v8 = v12 - 3;
    v7 = (signed int)dataa;
    v4 = v11 + 3;
    ++v6;
  }
  printbuff[v5] = 0;
  *(&valbuff[2 * v5] + v5) = 0;
}

//----- (00413EA0) --------------------------------------------------------
unsigned int __cdecl strlen_priv(const char *str)
{
  return strlen(str);
}

//----- (00413EC0) --------------------------------------------------------
void __cdecl failwithmessage(void *retaddr, int crttype, int errnum, const char *msg)
{
  int (*v4)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...); // edi@1
  unsigned int v5; // eax@3
  wchar_t *v6; // ebx@4
  char v7; // al@8
  unsigned int v8; // ST18_4@15
  int v9; // ST0C_4@15
  int v10; // eax@15
  char *v11; // esi@16
  char *v12; // edi@18
  int (__cdecl *v13)(int, char *, int, char *, const char *, unsigned int, const char *); // ebx@20
  unsigned int v14; // ST18_4@20
  int v15; // ST0C_4@20
  int lineNum; // [sp+10h] [bp-E38h]@14
  unsigned int Target; // [sp+14h] [bp-E34h]@1
  unsigned int dwErrorNumber; // [sp+18h] [bp-E30h]@1
  wchar_t msgB[512]; // [sp+1Ch] [bp-E2Ch]@4
  char moduleNameB[778]; // [sp+41Ch] [bp-A2Ch]@18
  char srcNameB[778]; // [sp+728h] [bp-720h]@16
  wchar_t moduleNameW[260]; // [sp+A34h] [bp-414h]@14
  wchar_t srcNameW[260]; // [sp+C3Ch] [bp-20Ch]@14

  dwErrorNumber = errnum;
  Target = 0;
  v4 = _RTC_GetErrorFuncW(retaddr);
  if ( !v4 )
    Target = (unsigned int)_RTC_GetErrorFunc(retaddr);
  v5 = MultiByteToWideChar(0xFDE9u, 0, msg, -1, 0, 0);
  if ( v5 >= 0x200 || (v6 = msgB, !MultiByteToWideChar(0xFDE9u, 0, msg, -1, msgB, v5)) )
    v6 = L"Runtime Check Error.\n\r Unable to display RTC Message.";
  if ( DebuggerProbe(0x1002u) )
  {
    if ( DebuggerRuntime(dwErrorNumber, RTC_NoFalsePositives[dwErrorNumber], retaddr, v6) )
      return;
    v7 = 0;
  }
  else
  {
    v7 = 1;
  }
  if ( !Target && !v4 || v7 && IsDebuggerPresent() )
    goto LABEL_25;
  _RTC_GetSrcLine((char *)retaddr - 5, srcNameW, 0x104u, &lineNum, moduleNameW, 0x104u);
  if ( v4 )
  {
    v8 = dwErrorNumber;
    v9 = lineNum;
    _guard_check_icall((unsigned int)v4);
    v10 = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v4)(
            crttype,
            srcNameW,
            v9,
            moduleNameW,
            L"Run-Time Check Failure #%d - %s",
            v8,
            v6);
  }
  else
  {
    v11 = "Unknown Filename";
    if ( WideCharToMultiByte(0xFDE9u, 0, srcNameW, -1, srcNameB, 778, 0, 0) )
      v11 = srcNameB;
    v12 = "Unknown Module Name";
    if ( WideCharToMultiByte(0xFDE9u, 0, moduleNameW, -1, moduleNameB, 778, 0, 0) )
      v12 = moduleNameB;
    v13 = (int (__cdecl *)(int, char *, int, char *, const char *, unsigned int, const char *))Target;
    v14 = dwErrorNumber;
    v15 = lineNum;
    _guard_check_icall(Target);
    v10 = v13(crttype, v11, v15, v12, "Run-Time Check Failure #%d - %s", v14, msg);
  }
  if ( v10 == 1 )
LABEL_25:
    __debugbreak();
}
// 41A068: using guessed type wchar_t aRuntimeCheckEr[54];
// 41A0F0: using guessed type wchar_t aRunTimeCheckFa[32];

//----- (00414140) --------------------------------------------------------
void __cdecl _RTC_UninitUse(const char *varname)
{
  const char *v1; // ebx@1
  int v2; // eax@4
  char v3; // cl@5
  char v4; // al@6
  unsigned int v5; // ebx@7
  char *v6; // edi@7
  char v7; // al@8
  unsigned int v8; // edx@9
  char *v9; // edi@9
  char v10; // al@10
  char *v11; // eax@11
  int crttype; // [sp+4h] [bp-408h]@1
  char msgB[1024]; // [sp+8h] [bp-404h]@11
  void *retaddr; // [sp+410h] [bp+4h]@13

  crttype = dword_41C034;
  v1 = varname;
  if ( dword_41C034 != -1 )
  {
    if ( varname && strlen_priv(varname) + 58 <= 0x400 )
    {
      v2 = 0;
      do
      {
        v3 = uninit_premsg[v2++];
        *((_BYTE *)&crttype + v2 + 3) = v3;
      }
      while ( v3 );
      do
        v4 = *v1++;
      while ( v4 );
      v5 = v1 - varname;
      v6 = (char *)&crttype + 3;
      do
        v7 = (v6++)[1];
      while ( v7 );
      qmemcpy(v6, varname, v5);
      v8 = strlen("' is being used without being initialized.") + 1;
      v9 = (char *)&crttype + 3;
      do
        v10 = (v9++)[1];
      while ( v10 );
      v11 = msgB;
      qmemcpy(v9, "' is being used without being initialized.", v8);
    }
    else
    {
      v11 = "A variable is being used without being initialized.";
    }
    failwithmessage(retaddr, crttype, 3, v11);
  }
}
// 41C034: using guessed type int dword_41C034;

//----- (00414270) --------------------------------------------------------
int __cdecl _vsprintf_s_l(char *const _Buffer, const unsigned int _BufferCount, const char *const _Format, __crt_locale_pointers *const _Locale, char *_ArgList)
{
  unsigned __int64 *v5; // eax@1
  int result; // eax@1

  v5 = j____local_stdio_printf_options();
  result = j____stdio_common_vsprintf_s(
             *(_DWORD *)v5,
             *((_DWORD *)v5 + 1),
             _Buffer,
             _BufferCount,
             _Format,
             _Locale,
             _ArgList);
  if ( result < 0 )
    result = -1;
  return result;
}
// 4111FE: using guessed type int __cdecl j____stdio_common_vsprintf_s(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004142B0) --------------------------------------------------------
int sprintf_s(char *const _Buffer, const unsigned int _BufferCount, const char *const _Format, ...)
{
  va_list va; // [sp+14h] [bp+14h]@1

  va_start(va, _Format);
  __vcrt_va_start_verify_argument_type<char const * const>();
  return j___vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, va);
}
// 41129E: using guessed type int __vcrt_va_start_verify_argument_type<char const * const>(void);

//----- (004142E0) --------------------------------------------------------
int __cdecl pre_c_initialization()
{
  _crt_app_type v0; // eax@1
  int v1; // eax@1
  int v2; // esi@1
  int v3; // eax@7

  v0 = __scrt_main_policy::get_app_type();
  j___set_app_type(v0);
  v1 = j___get_startup_file_mode();
  j___set_fmode(v1);
  v2 = j___get_startup_commit_mode();
  *(_DWORD *)j____p__commode() = v2;
  if ( !j____scrt_initialize_onexit_tables(dll) )
    j____scrt_fastfail(7u);
  __asm { fnclex }
  j___RTC_Initialize();
  j__atexit(j___RTC_Terminate);
  if ( __scrt_narrow_argv_policy::configure_argv() )
    j____scrt_fastfail(7u);
  __scrt_initialize_type_info();
  if ( j____scrt_is_user_matherr_present() )
    j____setusermatherr(j___matherr);
  j___initialize_invalid_parameter_handler();
  j___initialize_denormal_control();
  j___initialize_default_precision();
  v3 = j___get_startup_thread_locale_mode();
  j___configthreadlocale(v3);
  if ( j___should_initialize_environment() )
    initialize_environment();
  j____scrt_initialize_winrt();
  return 0;
}
// 411050: using guessed type int __cdecl j___configthreadlocale(_DWORD);
// 41106E: using guessed type int j___initialize_default_precision(void);
// 41114F: using guessed type int j___RTC_Initialize(void);
// 4111A9: using guessed type int j____p__commode(void);
// 4111AE: using guessed type int j____scrt_is_user_matherr_present(void);
// 41123A: using guessed type int j___initialize_invalid_parameter_handler(void);
// 41128A: using guessed type int __cdecl j___set_app_type(_DWORD);
// 4112A3: using guessed type int j___initialize_denormal_control(void);
// 411438: using guessed type int __cdecl j____setusermatherr(_DWORD);

//----- (004143D0) --------------------------------------------------------
int __cdecl post_pgo_initialization()
{
  j____scrt_initialize_default_local_stdio_options();
  return 0;
}
// 411352: using guessed type int j____scrt_initialize_default_local_stdio_options(void);

//----- (004143E0) --------------------------------------------------------
int pre_cpp_initialization()
{
  int v0; // eax@1

  j____scrt_set_unhandled_exception_filter();
  v0 = j___get_startup_new_mode();
  return j___set_new_mode(v0);
}
// 411203: using guessed type int j____scrt_set_unhandled_exception_filter(void);
// 411244: using guessed type int __cdecl j___set_new_mode(_DWORD);

//----- (00414400) --------------------------------------------------------
int __cdecl _scrt_common_main()
{
  j____security_init_cookie();
  return _scrt_common_main_seh();
}
// 4112DA: using guessed type int j____security_init_cookie(void);

//----- (00414420) --------------------------------------------------------
#error "41462B: positive sp value has been found (funcsize=126)"

//----- (004146B0) --------------------------------------------------------
int __cdecl __scrt_narrow_argv_policy::configure_argv()
{
  _crt_argv_mode v0; // eax@1

  v0 = j___get_startup_argv_mode();
  return j___configure_narrow_argv(v0);
}
// 411424: using guessed type int __cdecl j___configure_narrow_argv(_DWORD);

//----- (004146D0) --------------------------------------------------------
signed int __cdecl __scrt_main_policy::get_app_type()
{
  return 1;
}

//----- (004146E0) --------------------------------------------------------
int initialize_environment()
{
  return j___initialize_narrow_environment();
}
// 4112C1: using guessed type int j___initialize_narrow_environment(void);

//----- (004146F0) --------------------------------------------------------
int __cdecl invoke_main()
{
  int v0; // eax@1
  const char **v1; // ST04_4@1
  int *v2; // eax@1

  v0 = j___get_initial_narrow_environment();
  v1 = *(const char ***)j____p___argv(v0);
  v2 = (int *)j____p___argc();
  return j__main(*v2, v1);
}
// 41105F: using guessed type int j___get_initial_narrow_environment(void);
// 411384: using guessed type int j____p___argc(void);
// 41138E: using guessed type int __cdecl j____p___argv(_DWORD);

//----- (00414720) --------------------------------------------------------
int __cdecl mainCRTStartup()
{
  return _scrt_common_main();
}

//----- (00414730) --------------------------------------------------------
void __thiscall std::bad_alloc::bad_alloc(std::bad_alloc *this, const char *const _Message)
{
  std::bad_alloc *v2; // ST08_4@1

  v2 = this;
  std::exception::exception((std::exception *)&this->vfptr, _Message, 1);
  v2->vfptr = (std::exceptionVtbl *)&std::bad_alloc::`vftable';
}
// 41A370: using guessed type void *(__thiscall *std::bad_alloc::`vftable')(std::bad_alloc *this, unsigned int);

//----- (00414760) --------------------------------------------------------
void __thiscall std::bad_alloc::bad_alloc(std::bad_alloc *this, std::bad_alloc *__that)
{
  std::bad_alloc *v2; // ST04_4@1

  v2 = this;
  std::exception::exception((std::exception *)&this->vfptr, (std::exception *)&__that->vfptr);
  v2->vfptr = (std::exceptionVtbl *)&std::bad_alloc::`vftable';
}
// 41A370: using guessed type void *(__thiscall *std::bad_alloc::`vftable')(std::bad_alloc *this, unsigned int);

//----- (00414790) --------------------------------------------------------
void __thiscall std::bad_alloc::bad_alloc(std::bad_alloc *this)
{
  std::bad_alloc *v1; // ST08_4@1

  v1 = this;
  std::exception::exception((std::exception *)&this->vfptr, "bad allocation", 1);
  v1->vfptr = (std::exceptionVtbl *)&std::bad_alloc::`vftable';
}
// 41A370: using guessed type void *(__thiscall *std::bad_alloc::`vftable')(std::bad_alloc *this, unsigned int);

//----- (004147C0) --------------------------------------------------------
void __thiscall std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this, std::bad_array_new_length *__that)
{
  std::bad_array_new_length *v2; // ST04_4@1

  v2 = this;
  std::bad_alloc::bad_alloc((std::bad_alloc *)&this->vfptr, (std::bad_alloc *)&__that->vfptr);
  v2->vfptr = (std::exceptionVtbl *)&std::bad_array_new_length::`vftable';
}
// 41A394: using guessed type void *(__thiscall *std::bad_array_new_length::`vftable')(std::bad_array_new_length *this, unsigned int);

//----- (004147F0) --------------------------------------------------------
void __thiscall std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  std::bad_array_new_length *v1; // ST04_4@1

  v1 = this;
  std::bad_alloc::bad_alloc((std::bad_alloc *)&this->vfptr, "bad array new length");
  v1->vfptr = (std::exceptionVtbl *)&std::bad_array_new_length::`vftable';
}
// 41A394: using guessed type void *(__thiscall *std::bad_array_new_length::`vftable')(std::bad_array_new_length *this, unsigned int);

//----- (00414820) --------------------------------------------------------
void __thiscall std::exception::exception(std::exception *this, std::exception *_Other)
{
  char *v2; // edx@1

  this->vfptr = (std::exceptionVtbl *)&std::exception::`vftable';
  v2 = (char *)&this->_Data;
  *(_DWORD *)v2 = 0;
  *((_DWORD *)v2 + 1) = 0;
  j____std_exception_copy(&_Other->_Data, &this->_Data);
}
// 411190: using guessed type int __cdecl j____std_exception_copy(_DWORD, _DWORD);
// 41A348: using guessed type void *(__thiscall *std::exception::`vftable')(std::exception *this, unsigned int);

//----- (00414870) --------------------------------------------------------
void __thiscall std::exception::exception(std::exception *this, const char *const _Message, int __formal)
{
  char *v3; // edx@1

  this->vfptr = (std::exceptionVtbl *)&std::exception::`vftable';
  v3 = (char *)&this->_Data;
  *(_DWORD *)v3 = 0;
  *((_DWORD *)v3 + 1) = 0;
  *(_DWORD *)v3 = _Message;
}
// 41A348: using guessed type void *(__thiscall *std::exception::`vftable')(std::exception *this, unsigned int);

//----- (004148B0) --------------------------------------------------------
void __thiscall std::bad_alloc::~bad_alloc(std::bad_alloc *this)
{
  std::exception::~exception((std::exception *)&this->vfptr);
}

//----- (004148D0) --------------------------------------------------------
void __thiscall std::bad_array_new_length::~bad_array_new_length(std::bad_array_new_length *this)
{
  std::bad_alloc::~bad_alloc((std::bad_alloc *)&this->vfptr);
}

//----- (004148F0) --------------------------------------------------------
void __thiscall std::exception::~exception(std::exception *this)
{
  this->vfptr = (std::exceptionVtbl *)&std::exception::`vftable';
  j____std_exception_destroy(&this->_Data);
}
// 411389: using guessed type int __cdecl j____std_exception_destroy(_DWORD);
// 41A348: using guessed type void *(__thiscall *std::exception::`vftable')(std::exception *this, unsigned int);

//----- (00414920) --------------------------------------------------------
std::bad_alloc *__thiscall std::bad_alloc::`vector deleting destructor'(std::bad_alloc *this, unsigned int a2)
{
  std::bad_alloc *thisa; // [sp+0h] [bp-4h]@1

  thisa = this;
  std::bad_alloc::~bad_alloc(this);
  if ( a2 & 1 )
    operator delete(thisa, 0xCu);
  return thisa;
}

//----- (00414960) --------------------------------------------------------
std::bad_array_new_length *__thiscall std::bad_array_new_length::`scalar deleting destructor'(std::bad_array_new_length *this, unsigned int a2)
{
  std::bad_array_new_length *thisa; // [sp+0h] [bp-4h]@1

  thisa = this;
  std::bad_array_new_length::~bad_array_new_length(this);
  if ( a2 & 1 )
    operator delete(thisa, 0xCu);
  return thisa;
}

//----- (004149A0) --------------------------------------------------------
std::exception *__thiscall std::exception::`scalar deleting destructor'(std::exception *this, unsigned int a2)
{
  std::exception *thisa; // [sp+0h] [bp-4h]@1

  thisa = this;
  std::exception::~exception(this);
  if ( a2 & 1 )
    operator delete(thisa, 0xCu);
  return thisa;
}

//----- (004149E0) --------------------------------------------------------
void __cdecl __noreturn __scrt_throw_std_bad_alloc()
{
  std::bad_alloc v0; // [sp+0h] [bp-Ch]@1

  std::bad_alloc::bad_alloc(&v0);
  _CxxThrowException(&v0, &_TI2_AVbad_alloc_std__);
}
// 411451: using guessed type int __cdecl _CxxThrowException(_DWORD, _DWORD);

//----- (00414A10) --------------------------------------------------------
void __cdecl __noreturn __scrt_throw_std_bad_array_new_length()
{
  std::bad_array_new_length v0; // [sp+0h] [bp-Ch]@1

  std::bad_array_new_length::bad_array_new_length(&v0);
  _CxxThrowException(&v0, &_TI3_AVbad_array_new_length_std__);
}
// 411451: using guessed type int __cdecl _CxxThrowException(_DWORD, _DWORD);

//----- (00414A40) --------------------------------------------------------
const char *__thiscall std::exception::what(std::exception *this)
{
  const char *v2; // [sp+0h] [bp-8h]@2

  if ( this->_Data._What )
    v2 = this->_Data._What;
  else
    v2 = "Unknown exception";
  return v2;
}

//----- (00414A80) --------------------------------------------------------
void __cdecl operator delete(void *block)
{
  j___free_dbg(block, -1);
}
// 41108C: using guessed type int __cdecl j___free_dbg(_DWORD, _DWORD);

//----- (00414AA0) --------------------------------------------------------
void __cdecl __raise_securityfailure(_EXCEPTION_POINTERS *const exception_pointers)
{
  HANDLE v1; // eax@1

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(exception_pointers);
  v1 = GetCurrentProcess();
  TerminateProcess(v1, 0xC0000409);
}

//----- (00414AE0) --------------------------------------------------------
void __usercall __noreturn __report_gsfailure(unsigned int a1@<ebx>, unsigned int a2@<edi>, unsigned int a3@<esi>, char a4)
{
  unsigned int v4; // edx@1
  unsigned int v5; // ecx@1
  unsigned int v6; // et0@3
  unsigned int vars0; // [sp+324h] [bp+0h]@0
  void *retaddr; // [sp+328h] [bp+4h]@3

  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  GS_ContextRecord.Eax = 0;
  GS_ContextRecord.Ecx = v5;
  GS_ContextRecord.Edx = v4;
  GS_ContextRecord.Ebx = a1;
  GS_ContextRecord.Esi = a3;
  GS_ContextRecord.Edi = a2;
  LOWORD(GS_ContextRecord.SegSs) = __SS__;
  LOWORD(GS_ContextRecord.SegCs) = __CS__;
  LOWORD(GS_ContextRecord.SegDs) = __DS__;
  LOWORD(GS_ContextRecord.SegEs) = __ES__;
  LOWORD(GS_ContextRecord.SegFs) = __FS__;
  LOWORD(GS_ContextRecord.SegGs) = __GS__;
  v6 = __readeflags();
  GS_ContextRecord.EFlags = v6;
  GS_ContextRecord.Ebp = vars0;
  GS_ContextRecord.Eip = (unsigned int)retaddr;
  GS_ContextRecord.Esp = (unsigned int)&a4;
  GS_ContextRecord.ContextFlags = 65537;
  GS_ExceptionRecord.ExceptionAddress = retaddr;
  GS_ExceptionRecord.ExceptionCode = -1073740791;
  GS_ExceptionRecord.ExceptionFlags = 1;
  GS_ExceptionRecord.NumberParameters = 1;
  GS_ExceptionRecord.ExceptionInformation[0] = 2;
  j____raise_securityfailure(&GS_ExceptionPointers);
}

//----- (00414C30) --------------------------------------------------------
void __report_rangecheckfailure()
{
  j____report_securityfailure(8u);
}

//----- (00414C40) --------------------------------------------------------
void __usercall __report_securityfailure(unsigned int a1@<ebx>, unsigned int a2@<edi>, unsigned int a3@<esi>, unsigned int failure_code)
{
  unsigned int v4; // edx@1
  unsigned int v5; // ecx@1
  unsigned int v6; // et0@3
  unsigned int vars0; // [sp+31Ch] [bp+0h]@0
  void *retaddr; // [sp+320h] [bp+4h]@3

  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(failure_code);
  GS_ContextRecord.Eax = 0;
  GS_ContextRecord.Ecx = v5;
  GS_ContextRecord.Edx = v4;
  GS_ContextRecord.Ebx = a1;
  GS_ContextRecord.Esi = a3;
  GS_ContextRecord.Edi = a2;
  LOWORD(GS_ContextRecord.SegSs) = __SS__;
  LOWORD(GS_ContextRecord.SegCs) = __CS__;
  LOWORD(GS_ContextRecord.SegDs) = __DS__;
  LOWORD(GS_ContextRecord.SegEs) = __ES__;
  LOWORD(GS_ContextRecord.SegFs) = __FS__;
  LOWORD(GS_ContextRecord.SegGs) = __GS__;
  v6 = __readeflags();
  GS_ContextRecord.EFlags = v6;
  GS_ContextRecord.Ebp = vars0;
  GS_ContextRecord.Eip = (unsigned int)retaddr;
  GS_ContextRecord.Esp = (unsigned int)&failure_code;
  GS_ExceptionRecord.ExceptionAddress = retaddr;
  GS_ExceptionRecord.ExceptionCode = -1073740791;
  GS_ExceptionRecord.ExceptionFlags = 1;
  GS_ExceptionRecord.NumberParameters = 1;
  GS_ExceptionRecord.ExceptionInformation[0] = failure_code;
  j____raise_securityfailure(&GS_ExceptionPointers);
}

//----- (00414D50) --------------------------------------------------------
void __usercall __report_securityfailureEx(unsigned int a1@<ebx>, unsigned int a2@<edi>, unsigned int a3@<esi>, unsigned int failure_code, unsigned int parameter_count, void **parameters)
{
  unsigned int v6; // edx@1
  unsigned int v7; // ecx@1
  unsigned int v8; // et0@3
  unsigned int i; // [sp+31Ch] [bp-4h]@8
  unsigned int vars0; // [sp+320h] [bp+0h]@0
  void *retaddr; // [sp+324h] [bp+4h]@3

  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(failure_code);
  GS_ContextRecord.Eax = 0;
  GS_ContextRecord.Ecx = v7;
  GS_ContextRecord.Edx = v6;
  GS_ContextRecord.Ebx = a1;
  GS_ContextRecord.Esi = a3;
  GS_ContextRecord.Edi = a2;
  LOWORD(GS_ContextRecord.SegSs) = __SS__;
  LOWORD(GS_ContextRecord.SegCs) = __CS__;
  LOWORD(GS_ContextRecord.SegDs) = __DS__;
  LOWORD(GS_ContextRecord.SegEs) = __ES__;
  LOWORD(GS_ContextRecord.SegFs) = __FS__;
  LOWORD(GS_ContextRecord.SegGs) = __GS__;
  v8 = __readeflags();
  GS_ContextRecord.EFlags = v8;
  GS_ContextRecord.Ebp = vars0;
  GS_ContextRecord.Eip = (unsigned int)retaddr;
  GS_ContextRecord.Esp = (unsigned int)&failure_code;
  GS_ExceptionRecord.ExceptionAddress = retaddr;
  GS_ExceptionRecord.ExceptionCode = -1073740791;
  GS_ExceptionRecord.ExceptionFlags = 1;
  if ( parameter_count && !parameters )
    parameter_count = 0;
  if ( parameter_count > 0xE )
    --parameter_count;
  GS_ExceptionRecord.NumberParameters = parameter_count + 1;
  GS_ExceptionRecord.ExceptionInformation[0] = failure_code;
  for ( i = 0; i < parameter_count; ++i )
    GS_ExceptionRecord.ExceptionInformation[i + 1] = (unsigned int)parameters[i];
  j____raise_securityfailure(&GS_ExceptionPointers);
}

//----- (00414EC0) --------------------------------------------------------
int (*__cdecl _RTC_GetErrorFunc())(int, const char *, int, const char *, const char *, ...)
{
  return RTC_ErrorReportFunc;
}

//----- (00414ED0) --------------------------------------------------------
int (*__cdecl _RTC_GetErrorFuncW())(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...)
{
  return RTC_ErrorReportFuncW;
}

//----- (00414EE0) --------------------------------------------------------
const char *__cdecl _RTC_GetErrDesc(_RTC_ErrorNumber errnum)
{
  const char *result; // eax@2

  if ( (unsigned int)errnum > 4 )
    result = 0;
  else
    result = RTC_errlist[errnum];
  return result;
}

//----- (00414F00) --------------------------------------------------------
int __cdecl _RTC_NumErrors()
{
  return 5;
}

//----- (00414F10) --------------------------------------------------------
int (*__cdecl _RTC_SetErrorFunc(int (*func)(int, const char *, int, const char *, const char *, ...)))(int, const char *, int, const char *, const char *, ...)
{
  int (*result)(int, const char *, int, const char *, const char *, ...); // eax@1

  result = RTC_ErrorReportFunc;
  RTC_ErrorReportFunc = func;
  RTC_ErrorReportFuncW = 0;
  return result;
}

//----- (00414F40) --------------------------------------------------------
int (*__cdecl _RTC_SetErrorFuncW(int (*func)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...)))(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...)
{
  int (*result)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...); // eax@1

  result = RTC_ErrorReportFuncW;
  RTC_ErrorReportFuncW = func;
  RTC_ErrorReportFunc = 0;
  return result;
}

//----- (00414F70) --------------------------------------------------------
int __cdecl _RTC_SetErrorType(_RTC_ErrorNumber errnum, int type)
{
  int result; // eax@2

  if ( (unsigned int)errnum > 4 )
  {
    result = -1;
  }
  else
  {
    result = *(&_RTC_ErrorLevels + errnum);
    *(&_RTC_ErrorLevels + errnum) = type;
  }
  return result;
}

//----- (00414FA0) --------------------------------------------------------
HINSTANCE__ *__cdecl GetPdbDll()
{
  HINSTANCE__ *result; // eax@2
  int v1; // eax@3
  wchar_t sourcePath[260]; // [sp+0h] [bp-414h]@4
  wchar_t pdbPath[260]; // [sp+208h] [bp-20Ch]@5

  if ( alreadyTried
    || (alreadyTried = 1, (result = GetPdbDllFromInstallPath()) == 0)
    && ((v1 = j____vcrt_GetModuleHandleW(debugCrtFileName)) == 0
     || !j____vcrt_GetModuleFileNameW(v1, sourcePath, 260)
     || !GetPdbDllPathFromFilePath(sourcePath, pdbPath, 0x104u)
     || (result = (HINSTANCE__ *)j____vcrt_LoadLibraryExW(pdbPath, 0, 2304)) == 0
     && (GetLastError() != 87 || (result = (HINSTANCE__ *)j____vcrt_LoadLibraryExW(pdbPath, 0, 8)) == 0))
    && (result = (HINSTANCE__ *)j____vcrt_LoadLibraryExW(L"MSPDB140", 0, 2560)) == 0
    && (GetLastError() != 87
     || !j____vcrt_GetModuleFileNameW(0, sourcePath, 260)
     || !GetPdbDllPathFromFilePath(sourcePath, pdbPath, 0x104u)
     || (result = (HINSTANCE__ *)j____vcrt_LoadLibraryExW(pdbPath, 0, 8)) == 0) )
  {
    result = 0;
  }
  return result;
}
// 41143D: using guessed type int __cdecl j____vcrt_GetModuleFileNameW(_DWORD, _DWORD, _DWORD);
// 4114E2: using guessed type int __cdecl j____vcrt_LoadLibraryExW(_DWORD, _DWORD, _DWORD);
// 4114F1: using guessed type int __cdecl j____vcrt_GetModuleHandleW(_DWORD);
// 41A684: using guessed type wchar_t aMspdb140[9];

//----- (00415130) --------------------------------------------------------
HINSTANCE__ *__cdecl GetPdbDllFromInstallPath()
{
  HMODULE v0; // edi@1
  HINSTANCE__ *result; // eax@5
  HINSTANCE__ *v2; // esi@6
  FARPROC v3; // ebx@7
  HKEY__ *v4; // ST00_4@12
  int v5; // eax@12
  HKEY__ *v6; // ST14_4@12
  void (__stdcall *v7)(HKEY__ *); // ebx@12
  int v8; // esi@12
  unsigned int v9; // edx@15
  unsigned int v10; // ecx@16
  wchar_t *v11; // eax@16
  HINSTANCE__ *v12; // esi@21
  unsigned int type; // [sp+4h] [bp-21Ch]@12
  unsigned int Target; // [sp+8h] [bp-218h]@8
  unsigned int cb; // [sp+Ch] [bp-214h]@12
  HKEY__ *hkey; // [sp+10h] [bp-210h]@9
  wchar_t buf[260]; // [sp+14h] [bp-20Ch]@12

  v0 = (HMODULE)j____vcrt_LoadLibraryExW(L"api-ms-win-core-registry-l1-1-0.dll", 0, 2048);
  if ( !v0 )
  {
    v0 = (HMODULE)j____vcrt_LoadLibraryExW(L"advapi32.dll", 0, 2048);
    if ( !v0 )
    {
      if ( GetLastError() != 87 )
        return 0;
      v0 = (HMODULE)j____vcrt_LoadLibraryExW(L"advapi32.dll", 0, 0);
      if ( !v0 )
        return 0;
    }
  }
  result = (HINSTANCE__ *)GetProcAddress(v0, "RegOpenKeyExW");
  v2 = result;
  if ( result )
  {
    v3 = GetProcAddress(v0, "RegQueryValueExW");
    if ( !v3 )
      return 0;
    Target = (unsigned int)GetProcAddress(v0, "RegCloseKey");
    if ( !Target )
      return 0;
    _guard_check_icall((unsigned int)v2);
    if ( ((int (__stdcall *)(signed int, const wchar_t *, _DWORD, signed int, HKEY__ **))v2)(
           -2147483646,
           L"SOFTWARE\\Wow6432Node\\Microsoft\\VisualStudio\\14.0\\Setup\\VC",
           0,
           1,
           &hkey) )
    {
      FreeLibrary(v0);
      return 0;
    }
    cb = 520;
    v4 = hkey;
    _guard_check_icall((unsigned int)v3);
    v5 = ((int (__stdcall *)(HKEY__ *, const wchar_t *, _DWORD, unsigned int *, wchar_t *, unsigned int *))v3)(
           v4,
           L"ProductDir",
           0,
           &type,
           buf,
           &cb);
    v6 = hkey;
    v7 = (void (__stdcall *)(HKEY__ *))Target;
    v8 = v5;
    _guard_check_icall(Target);
    v7(v6);
    FreeLibrary(v0);
    if ( v8 )
      return 0;
    if ( type != 1 )
      return 0;
    if ( cb & 1 )
      return 0;
    v9 = cb >> 1;
    if ( cb >> 1 < 2 )
      return 0;
    v10 = (cb >> 1) - 1;
    v11 = &buf[v10];
    if ( buf[v10] )
      return 0;
    if ( *(v11 - 1) != 92 )
    {
      *v11 = 92;
      v10 = v9;
    }
    if ( ~v10 < 0x12 || v10 + 17 > 0x104 )
      return 0;
    *(_DWORD *)&buf[v10] = *(_DWORD *)mspdbName;
    *(_DWORD *)&buf[v10 + 2] = *(_DWORD *)&mspdbName[2];
    *(_DWORD *)&buf[v10 + 4] = *(_DWORD *)&mspdbName[4];
    *(_DWORD *)&buf[v10 + 6] = *(_DWORD *)&mspdbName[6];
    *(_DWORD *)&buf[v10 + 8] = *(_DWORD *)&mspdbName[8];
    *(_DWORD *)&buf[v10 + 10] = *(_DWORD *)&mspdbName[10];
    *(_DWORD *)&buf[v10 + 12] = *(_DWORD *)&mspdbName[12];
    *(_DWORD *)&buf[v10 + 14] = *(_DWORD *)&mspdbName[14];
    buf[v10 + 16] = mspdbName[16];
    v12 = (HINSTANCE__ *)j____vcrt_LoadLibraryExW(buf, 0, 2304);
    if ( !v12 && GetLastError() == 87 )
      v12 = (HINSTANCE__ *)j____vcrt_LoadLibraryExW(buf, 0, 8);
    result = v12;
  }
  return result;
}
// 4114E2: using guessed type int __cdecl j____vcrt_LoadLibraryExW(_DWORD, _DWORD, _DWORD);
// 41A508: using guessed type wchar_t aApiMsWinCoreRe[36];
// 41A560: using guessed type wchar_t aAdvapi32_dll[13];
// 41A5B8: using guessed type wchar_t aSoftwareWow643[58];
// 41A644: using guessed type wchar_t aProductdir[11];

//----- (00415450) --------------------------------------------------------
int __cdecl GetPdbDllPathFromFilePath(const wchar_t *sourcePath, wchar_t *pdbDllPath, unsigned int pdbDllPathSize)
{
  int result; // eax@2
  wchar_t dir[256]; // [sp+4h] [bp-60Ch]@1
  wchar_t fileName[256]; // [sp+204h] [bp-40Ch]@1
  wchar_t ext[256]; // [sp+404h] [bp-20Ch]@1
  wchar_t drive[3]; // [sp+604h] [bp-Ch]@1

  if ( j___wsplitpath_s(sourcePath, drive, 3u, dir, 0x100u, fileName, 0x100u, ext, 0x100u)
    || j__wcscpy_s(fileName, 9u, L"MSPDB140")
    || j__wcscpy_s(ext, 4u, L"DLL") )
  {
    result = 0;
  }
  else
  {
    result = j___wmakepath_s(pdbDllPath, pdbDllPathSize, drive, dir, fileName, ext) == 0;
  }
  return result;
}

//----- (00415560) --------------------------------------------------------
int __cdecl _RTC_GetSrcLine(char *address, wchar_t *source, unsigned int sourcelen, int *pline, wchar_t *moduleName, unsigned int modulelen)
{
  int v7; // eax@5
  char *v8; // edx@6
  unsigned int v9; // esi@7
  unsigned int v10; // edi@7
  unsigned int v11; // ebx@7
  int v12; // edx@7
  unsigned int v13; // eax@7
  _DWORD *v14; // ecx@8
  HMODULE v15; // eax@15
  FARPROC v16; // eax@18
  int (__cdecl *v17)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@18
  wchar_t *v18; // ST00_4@19
  PDB *v19; // edi@21
  unsigned int (__thiscall *v20)(PDB *); // esi@21
  PDB *v21; // edi@22
  int (__thiscall *v22)(PDB *, const char *, const char *, DBI **); // esi@22
  DBI *v23; // edi@23
  unsigned int *v24; // ST10_4@23
  int (__thiscall *v25)(DBI *, unsigned __int16, int, Mod **, unsigned __int16 *, int *, int *); // esi@23
  Mod *v26; // edi@24
  bool (__thiscall *v27)(Mod *, EnumLines **); // esi@24
  unsigned int *v28; // edi@26
  int (__thiscall *v29)(Enum *); // esi@26
  EnumLines *v30; // edi@27
  void (__thiscall *v31)(Enum *); // esi@27
  EnumLines *v32; // edi@31
  int (__thiscall *v33)(Enum *); // esi@31
  HANDLE v34; // eax@33
  EnumLines *v35; // edi@34
  void (__thiscall *v36)(Enum *); // esi@34
  Mod *v37; // edi@35
  int (__thiscall *v38)(Mod *); // esi@35
  DBI *v39; // edi@36
  int (__thiscall *v40)(DBI *); // esi@36
  PDB *v41; // edi@37
  int (__thiscall *v42)(PDB *); // esi@37
  SIZE_T v43; // ST24_4@40
  HANDLE v44; // eax@40
  unsigned int *v45; // eax@40
  EnumLines *v46; // edi@41
  unsigned int *v47; // ST24_4@41
  void (__thiscall *v48)(Enum *); // esi@41
  char v49; // al@41
  unsigned int v50; // ebx@42
  unsigned int i; // eax@43
  Mod *v52; // edi@46
  bool (__thiscall *v53)(Mod *, unsigned int, wchar_t *, unsigned int *, unsigned int *, char *, unsigned int *); // esi@46
  unsigned int v54; // ST10_4@46
  bool v55; // al@46
  int v56; // [sp-8h] [bp-58h]@3
  int v57; // [sp-4h] [bp-54h]@3
  _MEMORY_BASIC_INFORMATION mbi; // [sp+4h] [bp-4Ch]@1
  int ec; // [sp+20h] [bp-30h]@19
  unsigned int idFile; // [sp+24h] [bp-2Ch]@41
  unsigned int cbBlk; // [sp+28h] [bp-28h]@27
  int v62; // [sp+2Ch] [bp-24h]@21
  DBI *pdbi; // [sp+30h] [bp-20h]@22
  unsigned int offBlk; // [sp+34h] [bp-1Ch]@27
  PDB *ppdb; // [sp+38h] [bp-18h]@19
  Mod *pmod; // [sp+3Ch] [bp-14h]@23
  unsigned int cLines; // [sp+40h] [bp-10h]@27
  unsigned int *v68; // [sp+44h] [bp-Ch]@13
  EnumLines *penum; // [sp+48h] [bp-8h]@24
  unsigned __int16 segBlk; // [sp+4Ch] [bp-4h]@27

  *pline = 0;
  *source = 0;
  if ( !VirtualQuery(address - 1, &mbi, 0x1Cu) )
    return 0;
  if ( !j____vcrt_GetModuleFileNameW(mbi.AllocationBase, moduleName, modulelen) )
    return 0;
  if ( *(_WORD *)mbi.AllocationBase != 23117 )
    return 0;
  v7 = *((_DWORD *)mbi.AllocationBase + 15);
  if ( v7 <= 0 )
    return 0;
  v8 = (char *)mbi.AllocationBase + v7;
  if ( *(_DWORD *)((char *)mbi.AllocationBase + v7) != 17744 )
    return 0;
  v9 = address - 1 - mbi.AllocationBase;
  v10 = *((_WORD *)v8 + 3);
  v11 = 0;
  v12 = (int)&v8[*((_WORD *)v8 + 10)];
  v13 = 0;
  if ( v10 )
  {
    v14 = (_DWORD *)(v12 + 36);
    do
    {
      if ( v9 >= *v14 )
      {
        v11 = v9 - *v14;
        if ( v9 < *(v14 - 1) )
          break;
      }
      ++v13;
      v14 += 10;
    }
    while ( v13 < v10 );
  }
  if ( v13 == v10 )
    return 0;
  v68 = (unsigned int *)(v13 + 1);
  if ( PDBOK )
  {
    v15 = mspdb;
  }
  else
  {
    if ( mspdb )
      return 0;
    v15 = GetPdbDll();
    mspdb = v15;
    if ( !v15 )
      return 0;
    PDBOK = 1;
  }
  v16 = GetProcAddress(v15, "PDBOpenValidate5");
  v17 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v16;
  if ( !v16 )
    return 0;
  v18 = moduleName;
  _guard_check_icall((unsigned int)v16);
  if ( !v17(v18, 0, 0, 0, &ec, 0, 0, &ppdb) )
    return 0;
  v19 = ppdb;
  v62 = 0;
  v20 = ppdb->vfptr->QueryInterfaceVersion;
  _guard_check_icall((unsigned int)ppdb->vfptr->QueryInterfaceVersion);
  if ( ((int (__thiscall *)(PDB *, int, int))v20)(v19, v56, v57) == 20091201 )
  {
    v21 = ppdb;
    v22 = ppdb->vfptr->OpenDBI;
    _guard_check_icall((unsigned int)ppdb->vfptr->OpenDBI);
    if ( v22(v21, 0, "r", &pdbi) )
    {
      v23 = pdbi;
      v24 = v68;
      v25 = pdbi->vfptr->QueryModFromAddr;
      _guard_check_icall((unsigned int)pdbi->vfptr->QueryModFromAddr);
      if ( v25(v23, (unsigned __int16)v24, v11, &pmod, 0, 0, 0) )
      {
        v26 = pmod;
        penum = 0;
        v27 = pmod->vfptr->GetEnumLines;
        _guard_check_icall((unsigned int)pmod->vfptr->GetEnumLines);
        if ( v27(v26, &penum) && penum )
        {
          v28 = 0;
          v29 = penum->vfptr->next;
          _guard_check_icall((unsigned int)penum->vfptr->next);
          if ( v29((Enum *)&penum->vfptr) )
          {
            while ( 1 )
            {
              v30 = penum;
              v31 = penum->vfptr[1].release;
              _guard_check_icall((unsigned int)penum->vfptr[1].release);
              if ( !(unsigned __int8)((int (__thiscall *)(EnumLines *, _DWORD, unsigned int *, unsigned __int16 *, unsigned int *, unsigned int *, _DWORD))v31)(
                                       v30,
                                       0,
                                       &offBlk,
                                       &segBlk,
                                       &cbBlk,
                                       &cLines,
                                       0) )
                break;
              if ( (unsigned int *)segBlk == v68 && offBlk <= v11 && v11 < offBlk + cbBlk )
              {
                if ( !cLines )
                  break;
                if ( cLines >= 0x1FFFFFFF )
                  break;
                v43 = 8 * cLines;
                v44 = GetProcessHeap();
                v45 = (unsigned int *)HeapAlloc(v44, 0, v43);
                v68 = v45;
                if ( !v45 )
                  break;
                v46 = penum;
                v47 = v45;
                v48 = penum->vfptr[1].release;
                _guard_check_icall((unsigned int)penum->vfptr[1].release);
                v49 = ((int (__thiscall *)(EnumLines *, unsigned int *, _DWORD, _DWORD, _DWORD, unsigned int *, unsigned int *))v48)(
                        v46,
                        &idFile,
                        0,
                        0,
                        0,
                        &cLines,
                        v47);
                v28 = v68;
                if ( v49 )
                {
                  v50 = v11 - offBlk;
                  if ( v50 >= *v68 )
                  {
                    for ( i = 1; i < cLines; ++i )
                    {
                      if ( v50 < v68[2 * i] )
                        break;
                    }
                    v52 = pmod;
                    *pline = v68[2 * i - 1] & 0xFFFFFF;
                    v53 = v52->vfptr->QueryFileNameInfo;
                    v54 = idFile;
                    _guard_check_icall((unsigned int)v52->vfptr->QueryFileNameInfo);
                    v55 = v53(v52, v54, source, &sourcelen, 0, 0, 0);
                    v28 = v68;
                    if ( v55 )
                      v62 = 1;
                  }
                }
                goto DONE5;
              }
              v32 = penum;
              v33 = penum->vfptr->next;
              _guard_check_icall((unsigned int)penum->vfptr->next);
              if ( !v33((Enum *)&v32->vfptr) )
              {
                v28 = 0;
                goto DONE5;
              }
            }
          }
          else
          {
DONE5:
            v34 = GetProcessHeap();
            HeapFree(v34, 0, v28);
          }
          v35 = penum;
          v36 = penum->vfptr->release;
          _guard_check_icall((unsigned int)penum->vfptr->release);
          v36((Enum *)&v35->vfptr);
        }
        v37 = pmod;
        v38 = pmod->vfptr->Close;
        _guard_check_icall((unsigned int)pmod->vfptr->Close);
        v38(v37);
      }
      v39 = pdbi;
      v40 = pdbi->vfptr->Close;
      _guard_check_icall((unsigned int)pdbi->vfptr->Close);
      v40(v39);
    }
  }
  v41 = ppdb;
  v42 = ppdb->vfptr->Close;
  _guard_check_icall((unsigned int)ppdb->vfptr->Close);
  v42(v41);
  return v62;
}
// 41143D: using guessed type int __cdecl j____vcrt_GetModuleFileNameW(_DWORD, _DWORD, _DWORD);

//----- (00415990) --------------------------------------------------------
void __fastcall _guard_check_icall(unsigned int Target)
{
  __guard_check_icall_fptr(Target);
}
// 420000: using guessed type int (__cdecl *__guard_check_icall_fptr)(_DWORD);

//----- (004159B0) --------------------------------------------------------
int __cdecl _except_handler4(_EXCEPTION_RECORD *ExceptionRecord, _EXCEPTION_REGISTRATION_RECORD *EstablisherFrame, _CONTEXT *ContextRecord, void *DispatcherContext)
{
  return j___except_handler4_common(
           &__security_cookie,
           (const char *)__security_check_cookie,
           ExceptionRecord,
           EstablisherFrame,
           ContextRecord,
           DispatcherContext);
}
// 4110C3: using guessed type int j___except_handler4_common(_DWORD, const char *, ...);

//----- (004159E0) --------------------------------------------------------
void (__cdecl **__cdecl __crt_fast_decode_pointer<void (__cdecl **)(void)>(void (__cdecl **const p)()))()
{
  return (void (__cdecl **)())__crt_rotate_pointer_value(__security_cookie ^ (unsigned int)p, __security_cookie % 0x20u);
}

//----- (00415A10) --------------------------------------------------------
void (__cdecl **__cdecl __crt_fast_encode_pointer<void (__cdecl **)(void)>(void (__cdecl **const p)()))()
{
  return (void (__cdecl **)())(__security_cookie ^ __crt_rotate_pointer_value(
                                                     (const unsigned int)p,
                                                     32 - __security_cookie % 0x20u));
}

//----- (00415A50) --------------------------------------------------------
unsigned int __cdecl __crt_rotate_pointer_value(const unsigned int value, const int shift)
{
  return __ROR4__(value, shift);
}

//----- (00415A60) --------------------------------------------------------
_IMAGE_SECTION_HEADER *__cdecl find_pe_section(char *const image_base, const unsigned int rva)
{
  _IMAGE_NT_HEADERS *nt_header; // [sp+10h] [bp-8h]@1
  _IMAGE_SECTION_HEADER *it; // [sp+14h] [bp-4h]@1

  nt_header = (_IMAGE_NT_HEADERS *)&image_base[*((_DWORD *)image_base + 15)];
  for ( it = (_IMAGE_SECTION_HEADER *)((char *)&nt_header->OptionalHeader + nt_header->FileHeader.SizeOfOptionalHeader);
        it != (_IMAGE_SECTION_HEADER *)((char *)&nt_header->OptionalHeader
                                      + 40 * nt_header->FileHeader.NumberOfSections
                                      + nt_header->FileHeader.SizeOfOptionalHeader);
        ++it )
  {
    if ( rva >= it->VirtualAddress && rva < it->Misc.PhysicalAddress + it->VirtualAddress )
      return it;
  }
  return 0;
}

//----- (00415B10) --------------------------------------------------------
bool __cdecl is_potentially_valid_image_base(void *const image_base)
{
  bool result; // al@2
  _IMAGE_NT_HEADERS *nt_header; // [sp+8h] [bp-8h]@5

  if ( image_base )
  {
    if ( *(_WORD *)image_base == 23117 )
    {
      nt_header = (_IMAGE_NT_HEADERS *)((char *)image_base + *((_DWORD *)image_base + 15));
      if ( nt_header->Signature == 17744 )
        result = nt_header->OptionalHeader.Magic == 267;
      else
        result = 0;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00415BA0) --------------------------------------------------------
_TEB *__cdecl NtCurrentTeb()
{
  return (_TEB *)__readfsdword(24);
}

//----- (00415BB0) --------------------------------------------------------
char __cdecl __scrt_acquire_startup_lock()
{
  char result; // al@2
  void *owning_fiber; // [sp+0h] [bp-8h]@4
  void *this_fiber; // [sp+4h] [bp-4h]@3

  if ( j____scrt_is_ucrt_dll_in_use() )
  {
    this_fiber = (void *)*((_DWORD *)j__NtCurrentTeb() + 1);
    while ( 1 )
    {
      owning_fiber = (void *)_InterlockedCompareExchange(
                               (volatile signed __int32 *)&__scrt_native_startup_lock,
                               (signed __int32)this_fiber,
                               0);
      if ( !owning_fiber )
        break;
      if ( this_fiber == owning_fiber )
        return 1;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00415C10) --------------------------------------------------------
char __cdecl __scrt_dllmain_after_initialize_c()
{
  if ( j____scrt_is_ucrt_dll_in_use() )
  {
    j____isa_available_init();
  }
  else
  {
    if ( __scrt_narrow_argv_policy::configure_argv() )
      return 0;
    j___initialize_narrow_environment();
  }
  return 1;
}
// 4111B3: using guessed type int j____isa_available_init(void);
// 4112C1: using guessed type int j___initialize_narrow_environment(void);

//----- (00415C50) --------------------------------------------------------
bool __cdecl __scrt_dllmain_before_initialize_c()
{
  return j____scrt_initialize_onexit_tables(0) != 0;
}

//----- (00415C80) --------------------------------------------------------
char __cdecl __scrt_dllmain_crt_thread_attach()
{
  char result; // al@2

  if ( j____vcrt_thread_attach_1() )
  {
    if ( j____vcrt_thread_attach() )
    {
      result = 1;
    }
    else
    {
      j____acrt_thread_detach();
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00415CC0) --------------------------------------------------------
char __cdecl __scrt_dllmain_crt_thread_detach()
{
  j____acrt_thread_detach_0();
  j____acrt_thread_detach();
  return 1;
}

//----- (00415CE0) --------------------------------------------------------
int __cdecl __scrt_dllmain_exception_filter(HINSTANCE__ *instance, unsigned int reason, void *reserved, int (__stdcall *crt_dllmain)(HINSTANCE__ *, unsigned int, void *), unsigned int exception_code_, _EXCEPTION_POINTERS *exception_info_)
{
  if ( !j____scrt_is_ucrt_dll_in_use() && reason == 1 )
  {
    _guard_check_icall((unsigned int)crt_dllmain);
    crt_dllmain(instance, 0, reserved);
  }
  return j___seh_filter_dll(exception_code_, exception_info_);
}
// 41136B: using guessed type int __cdecl j___seh_filter_dll(_DWORD, _DWORD);

//----- (00415D40) --------------------------------------------------------
void __scrt_dllmain_uninitialize_c()
{
  if ( j____scrt_is_ucrt_dll_in_use() )
  {
    j___execute_onexit_table(&module_local_atexit_table);
  }
  else if ( !j___is_c_termination_complete() )
  {
    j___cexit();
  }
}
// 4114CE: using guessed type int __cdecl j___execute_onexit_table(_DWORD);

//----- (00415D80) --------------------------------------------------------
bool __scrt_dllmain_uninitialize_critical()
{
  bool savedregs; // [sp+0h] [bp+0h]@0

  j____acrt_uninitialize_critical_0(0);
  return j____acrt_uninitialize_critical_1(savedregs);
}

//----- (00415DA0) --------------------------------------------------------
char __cdecl __scrt_initialize_crt(__scrt_module_type module_type)
{
  char result; // al@4

  if ( module_type == 0 )
    is_initialized_as_dll = 1;
  j____isa_available_init();
  if ( j____scrt_stub_for_acrt_initialize_1() )
  {
    if ( j____scrt_stub_for_acrt_initialize() )
    {
      result = 1;
    }
    else
    {
      j____acrt_uninitialize_1(0);
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4111B3: using guessed type int j____isa_available_init(void);

//----- (00415E00) --------------------------------------------------------
bool __cdecl __scrt_initialize_onexit_tables(__scrt_module_type module_type)
{
  bool result; // al@7
  void (__cdecl **v2)(); // eax@9

  if ( module_type && module_type != 1 )
    j____scrt_fastfail(5u);
  if ( !j____scrt_is_ucrt_dll_in_use() || module_type )
  {
    v2 = __crt_fast_encode_pointer<void (__cdecl **)(void)>((void (__cdecl **const )())0xFFFFFFFF);
    module_local_atexit_table._first = v2;
    module_local_atexit_table._last = v2;
    module_local_atexit_table._end = v2;
    module_local_at_quick_exit_table._first = v2;
    module_local_at_quick_exit_table._last = v2;
    module_local_at_quick_exit_table._end = v2;
    result = 1;
  }
  else if ( j___initialize_onexit_table(&module_local_atexit_table) )
  {
    result = 0;
  }
  else
  {
    result = j___initialize_onexit_table(&module_local_at_quick_exit_table) == 0;
  }
  return result;
}
// 4112A8: using guessed type int __cdecl j___initialize_onexit_table(_DWORD);

//----- (00415F00) --------------------------------------------------------
bool __cdecl __scrt_is_nonwritable_in_current_image(const void *target)
{
  bool result; // al@2
  _IMAGE_SECTION_HEADER *section_header; // [sp+20h] [bp-28h]@3

  if ( is_potentially_valid_image_base((void *const )0x400000) )
  {
    section_header = find_pe_section((char *const )0x400000, (const unsigned int)target - 0x400000);
    if ( section_header )
      result = (section_header->Characteristics & 0x80000000) == 0;
    else
      result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00416080) --------------------------------------------------------
void __cdecl __scrt_release_startup_lock(bool is_nested)
{
  if ( j____scrt_is_ucrt_dll_in_use() )
  {
    if ( !is_nested )
      _InterlockedExchange((volatile signed __int32 *)&__scrt_native_startup_lock, 0);
  }
}

//----- (004160B0) --------------------------------------------------------
char __cdecl __scrt_uninitialize_crt(bool is_terminating, bool from_exit)
{
  char result; // al@3

  if ( is_initialized_as_dll && from_exit )
  {
    result = 1;
  }
  else
  {
    j____acrt_uninitialize(is_terminating);
    j____acrt_uninitialize_1(is_terminating);
    result = 1;
  }
  return result;
}

//----- (00416100) --------------------------------------------------------
int (__cdecl *__cdecl _onexit(int (__cdecl *function)()))()
{
  int (__cdecl *result)(); // eax@5
  int (__cdecl *v2)(); // [sp+4h] [bp-8h]@7
  int (__cdecl *v3)(); // [sp+8h] [bp-4h]@3

  if ( __crt_fast_decode_pointer<void (__cdecl **)(void)>(module_local_atexit_table._first) == (void (__cdecl **)())-1 )
  {
    if ( j___crt_atexit(function) )
      v3 = 0;
    else
      v3 = function;
    result = v3;
  }
  else
  {
    if ( j___register_onexit_function(&module_local_atexit_table, function) )
      v2 = 0;
    else
      v2 = function;
    result = v2;
  }
  return result;
}
// 41139D: using guessed type int __cdecl j___register_onexit_function(_DWORD, _DWORD);
// 411497: using guessed type int __cdecl j___crt_atexit(_DWORD);

//----- (00416190) --------------------------------------------------------
int __cdecl at_quick_exit(void (__cdecl *function)())
{
  int result; // eax@2

  if ( __crt_fast_decode_pointer<void (__cdecl **)(void)>(module_local_at_quick_exit_table._first) == (void (__cdecl **)())-1 )
    result = j___crt_at_quick_exit(function);
  else
    result = j___register_onexit_function(&module_local_at_quick_exit_table, function);
  return result;
}
// 411217: using guessed type int __cdecl j___crt_at_quick_exit(_DWORD);
// 41139D: using guessed type int __cdecl j___register_onexit_function(_DWORD, _DWORD);

//----- (004161F0) --------------------------------------------------------
int __cdecl atexit(void (__cdecl *function)())
{
  signed int v2; // [sp+0h] [bp-4h]@2

  if ( j___onexit((int (__cdecl *)())function) )
    v2 = 0;
  else
    v2 = -1;
  return v2;
}

//----- (00416230) --------------------------------------------------------
unsigned int __security_init_cookie()
{
  unsigned int result; // eax@2
  _LARGE_INTEGER perfctr; // [sp+0h] [bp-14h]@4
  FT systime; // [sp+8h] [bp-Ch]@1
  unsigned int cookie; // [sp+10h] [bp-4h]@4

  systime.ft_scalar = 0i64;
  if ( __security_cookie != -1153374642 && (result = __security_cookie & 0xFFFF0000) != 0 )
  {
    __security_cookie_complement = ~__security_cookie;
  }
  else
  {
    GetSystemTimeAsFileTime((LPFILETIME)&systime);
    cookie = systime.ft_struct.dwHighDateTime ^ systime.ft_struct.dwLowDateTime;
    cookie ^= GetCurrentThreadId();
    cookie ^= GetCurrentProcessId();
    QueryPerformanceCounter(&perfctr);
    cookie ^= perfctr.LowPart;
    cookie ^= perfctr.HighPart;
    cookie ^= (unsigned int)&cookie;
    if ( cookie == -1153374642 )
    {
      cookie = -1153374641;
    }
    else if ( !(cookie & 0xFFFF0000) )
    {
      cookie |= (cookie | 0x4711) << 16;
    }
    result = cookie;
    __security_cookie = cookie;
    __security_cookie_complement = ~cookie;
  }
  return result;
}
// 41C040: using guessed type int __security_cookie_complement;

//----- (00416350) --------------------------------------------------------
int __cdecl _matherr()
{
  return 0;
}

//----- (00416360) --------------------------------------------------------
signed int __cdecl _get_startup_argv_mode()
{
  return 1;
}

//----- (00416370) --------------------------------------------------------
int __cdecl _get_startup_commit_mode()
{
  return 0;
}

//----- (00416380) --------------------------------------------------------
int __cdecl _get_startup_file_mode()
{
  return 0x4000;
}

//----- (00416390) --------------------------------------------------------
int __cdecl _get_startup_new_mode()
{
  return 0;
}

//----- (004163A0) --------------------------------------------------------
int __cdecl _get_startup_thread_locale_mode()
{
  return 0;
}

//----- (004163B0) --------------------------------------------------------
void __cdecl __scrt_initialize_type_info()
{
  InitializeSListHead(&__type_info_root_node);
}

//----- (004163D0) --------------------------------------------------------
void __cdecl __scrt_uninitialize_type_info()
{
  j____std_type_info_destroy_list(&__type_info_root_node);
}
// 41116D: using guessed type int __cdecl j____std_type_info_destroy_list(_DWORD);

//----- (004163F0) --------------------------------------------------------
char __cdecl _should_initialize_environment()
{
  return 1;
}

//----- (00416400) --------------------------------------------------------
void _initialize_default_precision()
{
  if ( j___controlfp_s(0, 0x10000u, 0x30000u) )
    j____scrt_fastfail(7u);
}

//----- (00416430) --------------------------------------------------------
void _initialize_invalid_parameter_handler()
{
  ;
}

//----- (00416440) --------------------------------------------------------
void _initialize_denormal_control()
{
  ;
}

//----- (00416450) --------------------------------------------------------
unsigned __int64 *__cdecl __local_stdio_scanf_options()
{
  return &`__local_stdio_scanf_options'::`2'::_OptionsStorage;
}

//----- (00416460) --------------------------------------------------------
int __scrt_initialize_default_local_stdio_options()
{
  unsigned __int64 *v0; // eax@1
  int v1; // edx@1
  unsigned __int64 *v2; // eax@1
  unsigned __int64 *v3; // ST00_4@1
  int v4; // edx@1
  int result; // eax@1

  v0 = j____local_stdio_printf_options();
  v1 = *((_DWORD *)v0 + 1);
  *(_DWORD *)v0 |= 4u;
  *((_DWORD *)v0 + 1) = v1;
  v2 = j____local_stdio_scanf_options();
  v3 = v2;
  v4 = *(_DWORD *)v2 | 2;
  result = *((_DWORD *)v2 + 1);
  *(_DWORD *)v3 = v4;
  *((_DWORD *)v3 + 1) = result;
  return result;
}

//----- (004164B0) --------------------------------------------------------
BOOL __scrt_is_user_matherr_present()
{
  return __scrt_default_matherr == 0;
}
// 41C050: using guessed type int __scrt_default_matherr;

//----- (004164E0) --------------------------------------------------------
void *__scrt_get_dyn_tls_init_callback()
{
  return &__dyn_tls_init_callback;
}

//----- (004164F0) --------------------------------------------------------
void *__scrt_get_dyn_tls_dtor_callback()
{
  return &__dyn_tls_dtor_callback;
}

//----- (00416500) --------------------------------------------------------
void __usercall __scrt_fastfail(unsigned int a1@<ebx>, unsigned int a2@<edi>, unsigned int a3@<esi>, unsigned int code)
{
  void *v4; // eax@3
  unsigned int v5; // ecx@3
  unsigned int v6; // edx@3
  unsigned int v7; // et0@3
  _CONTEXT context_record; // [sp+0h] [bp-32Ch]@3
  _EXCEPTION_RECORD exception_record; // [sp+2CCh] [bp-60h]@3
  _EXCEPTION_POINTERS exception_pointers; // [sp+31Ch] [bp-10h]@3
  const int result; // [sp+324h] [bp-8h]@3
  const bool was_debugger_present; // [sp+32Ah] [bp-2h]@3
  bool v13; // [sp+32Bh] [bp-1h]@3
  unsigned int savedregs; // [sp+32Ch] [bp+0h]@3
  void *retaddr; // [sp+330h] [bp+4h]@3

  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(code);
  j___crt_debugger_hook(3);
  v4 = j__memset(&context_record, 0, 0x2CCu);
  context_record.Eax = (unsigned int)v4;
  context_record.Ecx = v5;
  context_record.Edx = v6;
  context_record.Ebx = a1;
  context_record.Esi = a3;
  context_record.Edi = a2;
  LOWORD(context_record.SegSs) = __SS__;
  LOWORD(context_record.SegCs) = __CS__;
  LOWORD(context_record.SegDs) = __DS__;
  LOWORD(context_record.SegEs) = __ES__;
  LOWORD(context_record.SegFs) = __FS__;
  LOWORD(context_record.SegGs) = __GS__;
  v7 = __readeflags();
  context_record.EFlags = v7;
  context_record.ContextFlags = 65537;
  context_record.Eip = (unsigned int)retaddr;
  context_record.Esp = (unsigned int)&retaddr;
  context_record.Ebp = savedregs;
  j__memset(&exception_record, 0, 0x50u);
  exception_record.ExceptionCode = 1073741845;
  exception_record.ExceptionFlags = 1;
  exception_record.ExceptionAddress = retaddr;
  v13 = IsDebuggerPresent() == 1;
  was_debugger_present = v13;
  exception_pointers.ExceptionRecord = &exception_record;
  exception_pointers.ContextRecord = &context_record;
  SetUnhandledExceptionFilter(0);
  result = UnhandledExceptionFilter(&exception_pointers);
  if ( !result && !was_debugger_present )
    j___crt_debugger_hook(3);
}

//----- (00416690) --------------------------------------------------------
unsigned __int16 __cdecl __scrt_get_show_window_mode()
{
  _STARTUPINFOW startup_info; // [sp+0h] [bp-48h]@1
  int v2; // [sp+44h] [bp-4h]@2

  j__memset(&startup_info, 0, 0x44u);
  GetStartupInfoW(&startup_info);
  if ( startup_info.dwFlags & 1 )
    v2 = startup_info.wShowWindow;
  else
    v2 = 10;
  return v2;
}

//----- (004166E0) --------------------------------------------------------
int __cdecl __scrt_initialize_winrt()
{
  return 0;
}

//----- (004166F0) --------------------------------------------------------
bool __cdecl __scrt_is_managed_app()
{
  bool result; // al@2
  _IMAGE_NT_HEADERS *pe_header; // [sp+0h] [bp-8h]@5
  HMODULE dos_header; // [sp+4h] [bp-4h]@1

  dos_header = GetModuleHandleW(0);
  if ( dos_header )
  {
    if ( *(_WORD *)dos_header == 23117 )
    {
      pe_header = (_IMAGE_NT_HEADERS *)((char *)dos_header + *((_DWORD *)dos_header + 15));
      if ( pe_header->Signature == 17744 )
      {
        if ( pe_header->OptionalHeader.Magic == 267 )
        {
          if ( pe_header->OptionalHeader.NumberOfRvaAndSizes > 0xE )
            result = pe_header->OptionalHeader.DataDirectory[14].VirtualAddress != 0;
          else
            result = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004167A0) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER __scrt_set_unhandled_exception_filter()
{
  return SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)__scrt_unhandled_exception_filter);
}

//----- (004167C0) --------------------------------------------------------
int __stdcall __scrt_unhandled_exception_filter(_EXCEPTION_POINTERS *const pointers)
{
  _EXCEPTION_RECORD *exception_record; // [sp+0h] [bp-4h]@1

  exception_record = pointers->ExceptionRecord;
  if ( pointers->ExceptionRecord->ExceptionCode == -529697949
    && exception_record->NumberParameters == 3
    && (exception_record->ExceptionInformation[0] == 429065504
     || exception_record->ExceptionInformation[0] == 429065505
     || exception_record->ExceptionInformation[0] == 429065506
     || exception_record->ExceptionInformation[0] == 26820608) )
  {
    j__terminate();
  }
  return 0;
}
// 4112FD: using guessed type int j__terminate(void);

//----- (00416840) --------------------------------------------------------
void __cdecl _crt_debugger_hook()
{
  __scrt_debugger_hook_flag = 0;
}
// 41C91C: using guessed type int __scrt_debugger_hook_flag;

//----- (00416860) --------------------------------------------------------
void *_RTC_Initialize()
{
  unsigned int *v0; // esi@1
  void *result; // eax@1
  int (*v2)(void); // edi@2

  v0 = (unsigned int *)&unk_41ACB0;
  result = &unk_41ACB0;
  if ( &unk_41ACB0 < &__rtc_izz )
  {
    do
    {
      v2 = (int (*)(void))*v0;
      if ( *v0 )
      {
        _guard_check_icall(*v0);
        result = (void *)v2();
      }
      ++v0;
    }
    while ( v0 < (unsigned int *)&__rtc_izz );
  }
  return result;
}

//----- (004168A0) --------------------------------------------------------
void *_RTC_Terminate()
{
  unsigned int *v0; // esi@1
  void *result; // eax@1
  int (*v2)(void); // edi@2

  v0 = (unsigned int *)&unk_41AFBC;
  result = &unk_41AFBC;
  if ( &unk_41AFBC < &__rtc_tzz )
  {
    do
    {
      v2 = (int (*)(void))*v0;
      if ( *v0 )
      {
        _guard_check_icall(*v0);
        result = (void *)v2();
      }
      ++v0;
    }
    while ( v0 < (unsigned int *)&__rtc_tzz );
  }
  return result;
}

//----- (004168E0) --------------------------------------------------------
void __thiscall type_info::~type_info(type_info *this)
{
  this->vfptr = (type_infoVtbl *)&type_info::`vftable';
}
// 41A6B8: using guessed type void *(__thiscall *type_info::`vftable')(type_info *this, unsigned int);

//----- (00416900) --------------------------------------------------------
type_info *__thiscall type_info::`scalar deleting destructor'(type_info *this, unsigned int a2)
{
  type_info *thisa; // [sp+0h] [bp-4h]@1

  thisa = this;
  type_info::~type_info(this);
  if ( a2 & 1 )
    operator delete(thisa, 0xCu);
  return thisa;
}

//----- (00416940) --------------------------------------------------------
void _guard_check_icall_nop()
{
  ;
}

//----- (00416950) --------------------------------------------------------
BOOL __cdecl _guard_icall_checks_enforced()
{
  return (char *)__guard_check_icall_fptr != (char *)_guard_check_icall_nop;
}
// 420000: using guessed type int (__cdecl *__guard_check_icall_fptr)(_DWORD);

//----- (00416980) --------------------------------------------------------
int __isa_available_init()
{
  int result; // eax@2
  bool GenuineIntel; // ST2B_1@3
  int leaves_supported; // [sp+18h] [bp-30h]@3
  int FeatureInformation_4; // [sp+3Ch] [bp-Ch]@11

  __isa_available = 0;
  __isa_enabled |= 1u;
  if ( IsProcessorFeaturePresent(0xAu) )
  {
    __isa_available = 1;
    __isa_enabled |= 2u;
    _EAX = 0;
    __asm { cpuid }
    leaves_supported = _EAX;
    GenuineIntel = (_ECX ^ 0x6C65746E | _EDX ^ 0x49656E69 | _EBX ^ 0x756E6547) == 0;
    _EAX = 1;
    __asm { cpuid }
    if ( GenuineIntel
      && ((_EAX & 0xFFF3FF0) == 67264
       || (_EAX & 0xFFF3FF0) == 132704
       || (_EAX & 0xFFF3FF0) == 132720
       || (_EAX & 0xFFF3FF0) == 198224
       || (_EAX & 0xFFF3FF0) == 198240
       || (_EAX & 0xFFF3FF0) == 198256) )
    {
      __favor |= 1u;
    }
    FeatureInformation_4 = _ECX;
    if ( leaves_supported >= 7 )
    {
      _EAX = 7;
      __asm { cpuid }
      if ( _EBX & 0x200 )
        __favor |= 2u;
    }
    if ( FeatureInformation_4 & 0x100000 )
    {
      __isa_available = 2;
      __isa_enabled |= 4u;
      if ( FeatureInformation_4 & 0x8000000 )
      {
        if ( FeatureInformation_4 & 0x10000000 )
          __asm { xgetbv }
      }
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 41C050: using guessed type int __scrt_default_matherr;
// 41C054: using guessed type int __isa_enabled;
// 41C920: using guessed type int __isa_available;
// 41C924: using guessed type int __favor;

//----- (00416D10) --------------------------------------------------------
BOOL __scrt_is_ucrt_dll_in_use()
{
  return __scrt_ucrt_dll_is_in_use != 0;
}
// 41C058: using guessed type int __scrt_ucrt_dll_is_in_use;

//----- (00416F00) --------------------------------------------------------
char __cdecl __scrt_stub_for_acrt_initialize()
{
  return 1;
}

//----- (00416F10) --------------------------------------------------------
char __cdecl __vcrt_thread_attach()
{
  return 1;
}

//----- (00416F20) --------------------------------------------------------
char __cdecl __acrt_thread_detach()
{
  return 1;
}

//----- (00416F30) --------------------------------------------------------
char __cdecl __acrt_uninitialize()
{
  return 1;
}

//----- (00416F40) --------------------------------------------------------
char __cdecl __acrt_uninitialize_critical()
{
  return 1;
}

//----- (00416F50) --------------------------------------------------------
int __cdecl _is_c_termination_complete()
{
  return 0;
}

//----- (00417DB0) --------------------------------------------------------
void __usercall _unwindfunclet_____6U__char_traits_D_std___std__YAAAV__basic_ostream_DU__char_traits_D_std___0_AAV10_PBD_Z_2(int a1@<ebp>)
{
  std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry((std::basic_ostream<char,std::char_traits<char> >::sentry *)(a1 - 72));
}

//----- (00417DE0) --------------------------------------------------------
void __usercall _unwindfunclet___0sentry___basic_ostream_DU__char_traits_D_std___std__QAE_AAV12__Z_0(int a1@<ebp>)
{
  std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(*(std::basic_ostream<char,std::char_traits<char> >::_Sentry_base **)(a1 - 20));
}

#error "There were 2 decompilation failure(s) on 148 function(s)"
